// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.book-manager.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bookSetHasCover = `-- name: BookSetHasCover :exec
update books
set has_cover = $2
where id = $1
`

type BookSetHasCoverParams struct {
	ID       int64
	HasCover bool
}

func (q *Queries) BookSetHasCover(ctx context.Context, arg BookSetHasCoverParams) error {
	_, err := q.db.Exec(ctx, bookSetHasCover, arg.ID, arg.HasCover)
	return err
}

const getChapterOrder = `-- name: GetChapterOrder :many
select "order", id
from book_chapters
where book_id = $1
order by "order"
`

type GetChapterOrderRow struct {
	Order int32
	ID    int64
}

func (q *Queries) GetChapterOrder(ctx context.Context, bookID int64) ([]GetChapterOrderRow, error) {
	rows, err := q.db.Query(ctx, getChapterOrder, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChapterOrderRow
	for rows.Next() {
		var i GetChapterOrderRow
		if err := rows.Scan(&i.Order, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastChapterOrder = `-- name: GetLastChapterOrder :one
select cast(coalesce(max("order"), 0) as int4) as last_order
from book_chapters
where book_id = $1
`

func (q *Queries) GetLastChapterOrder(ctx context.Context, bookID int64) (int32, error) {
	row := q.db.QueryRow(ctx, getLastChapterOrder, bookID)
	var last_order int32
	err := row.Scan(&last_order)
	return last_order, err
}

const insertBook = `-- name: InsertBook :exec
insert into books 
(
    id, name, summary, author_user_id, created_at, age_rating, tag_ids, cached_parent_tag_ids,
    is_publicly_visible
)
values 
(
    $1, $2, $3, $4, $5, $6, $7, $8, 
    $9
)
`

type InsertBookParams struct {
	ID                 int64
	Name               string
	Summary            string
	AuthorUserID       pgtype.UUID
	CreatedAt          pgtype.Timestamptz
	AgeRating          AgeRating
	TagIds             []int64
	CachedParentTagIds []int64
	IsPubliclyVisible  bool
}

func (q *Queries) InsertBook(ctx context.Context, arg InsertBookParams) error {
	_, err := q.db.Exec(ctx, insertBook,
		arg.ID,
		arg.Name,
		arg.Summary,
		arg.AuthorUserID,
		arg.CreatedAt,
		arg.AgeRating,
		arg.TagIds,
		arg.CachedParentTagIds,
		arg.IsPubliclyVisible,
	)
	return err
}

const insertBookChapter = `-- name: InsertBookChapter :exec
insert into book_chapters
(id, name, book_id, content, "order", created_at, words, summary)
values ($1, $2, $3, $4, $5, $6, $7, $8)
`

type InsertBookChapterParams struct {
	ID        int64
	Name      string
	BookID    int64
	Content   string
	Order     int32
	CreatedAt pgtype.Timestamptz
	Words     int32
	Summary   string
}

func (q *Queries) InsertBookChapter(ctx context.Context, arg InsertBookChapterParams) error {
	_, err := q.db.Exec(ctx, insertBookChapter,
		arg.ID,
		arg.Name,
		arg.BookID,
		arg.Content,
		arg.Order,
		arg.CreatedAt,
		arg.Words,
		arg.Summary,
	)
	return err
}

const managerGetUserBooks = `-- name: ManagerGetUserBooks :many
select 
    books.id, books.name, books.summary, books.author_user_id, books.created_at, books.age_rating, books.is_publicly_visible, books.is_banned, books.words, books.chapters, books.tag_ids, books.cached_parent_tag_ids, books.has_cover, books.view, books.rating, books.total_reviews, books.total_ratings, books.is_pinned,
    collections.id as collection_id,
    collections.name as collection_name,
    collection_books."order" as collection_position,
    collections.books_count as collection_size
from books
left join collection_books on books.id = collection_books.book_id
left join collections on collection_books.collection_id = collections.id
where author_user_id = $1
order by books.created_at desc
limit $2 offset $3
`

type ManagerGetUserBooksParams struct {
	AuthorUserID pgtype.UUID
	Limit        int32
	Offset       int32
}

type ManagerGetUserBooksRow struct {
	ID                 int64
	Name               string
	Summary            string
	AuthorUserID       pgtype.UUID
	CreatedAt          pgtype.Timestamptz
	AgeRating          AgeRating
	IsPubliclyVisible  bool
	IsBanned           bool
	Words              int32
	Chapters           int32
	TagIds             []int64
	CachedParentTagIds []int64
	HasCover           bool
	View               int32
	Rating             pgtype.Float8
	TotalReviews       int32
	TotalRatings       int32
	IsPinned           bool
	CollectionID       pgtype.Int8
	CollectionName     pgtype.Text
	CollectionPosition pgtype.Int4
	CollectionSize     pgtype.Int4
}

func (q *Queries) ManagerGetUserBooks(ctx context.Context, arg ManagerGetUserBooksParams) ([]ManagerGetUserBooksRow, error) {
	rows, err := q.db.Query(ctx, managerGetUserBooks, arg.AuthorUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ManagerGetUserBooksRow
	for rows.Next() {
		var i ManagerGetUserBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Summary,
			&i.AuthorUserID,
			&i.CreatedAt,
			&i.AgeRating,
			&i.IsPubliclyVisible,
			&i.IsBanned,
			&i.Words,
			&i.Chapters,
			&i.TagIds,
			&i.CachedParentTagIds,
			&i.HasCover,
			&i.View,
			&i.Rating,
			&i.TotalReviews,
			&i.TotalRatings,
			&i.IsPinned,
			&i.CollectionID,
			&i.CollectionName,
			&i.CollectionPosition,
			&i.CollectionSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recalculateBookStats = `-- name: RecalculateBookStats :exec
update books
set words = stat.words, chapters = stat.chapters
from (select sum(words) as words, count(1) as chapters from book_chapters where book_id = $1) as stat
where books.id = $1
`

func (q *Queries) RecalculateBookStats(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, recalculateBookStats, id)
	return err
}

const setChapterOrder = `-- name: SetChapterOrder :exec
update book_chapters
set "order" = $2
where id = $1
`

type SetChapterOrderParams struct {
	ID    int64
	Order int32
}

func (q *Queries) SetChapterOrder(ctx context.Context, arg SetChapterOrderParams) error {
	_, err := q.db.Exec(ctx, setChapterOrder, arg.ID, arg.Order)
	return err
}

const updateBook = `-- name: UpdateBook :exec
update books
set name = $2, age_rating = $3, tag_ids = $4, cached_parent_tag_ids = $5, summary = $6, is_publicly_visible = $7,
    has_cover = $8
where id = $1
`

type UpdateBookParams struct {
	ID                 int64
	Name               string
	AgeRating          AgeRating
	TagIds             []int64
	CachedParentTagIds []int64
	Summary            string
	IsPubliclyVisible  bool
	HasCover           bool
}

func (q *Queries) UpdateBook(ctx context.Context, arg UpdateBookParams) error {
	_, err := q.db.Exec(ctx, updateBook,
		arg.ID,
		arg.Name,
		arg.AgeRating,
		arg.TagIds,
		arg.CachedParentTagIds,
		arg.Summary,
		arg.IsPubliclyVisible,
		arg.HasCover,
	)
	return err
}

const updateBookChapter = `-- name: UpdateBookChapter :one
update book_chapters
set name = $2, content = $3, words = $4, summary = $5
where id = $1
returning book_chapters.book_id
`

type UpdateBookChapterParams struct {
	ID      int64
	Name    string
	Content string
	Words   int32
	Summary string
}

func (q *Queries) UpdateBookChapter(ctx context.Context, arg UpdateBookChapterParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateBookChapter,
		arg.ID,
		arg.Name,
		arg.Content,
		arg.Words,
		arg.Summary,
	)
	var book_id int64
	err := row.Scan(&book_id)
	return book_id, err
}
