// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.book-manager.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bookSetCover = `-- name: BookSetCover :exec
update books
set cover = $2
where id = $1
`

type BookSetCoverParams struct {
	ID    int64
	Cover string
}

func (q *Queries) BookSetCover(ctx context.Context, arg BookSetCoverParams) error {
	_, err := q.db.Exec(ctx, bookSetCover, arg.ID, arg.Cover)
	return err
}

const book_Book_ManagerGetUserBooksCount = `-- name: Book_Book_ManagerGetUserBooksCount :one
select count(1)
from books
where author_user_id = $1 and ($2::text = '' or position(lower($2::text) in lower(books.name)) > 0)
`

type Book_Book_ManagerGetUserBooksCountParams struct {
	AuthorUserID pgtype.UUID
	Search       string
}

func (q *Queries) Book_Book_ManagerGetUserBooksCount(ctx context.Context, arg Book_Book_ManagerGetUserBooksCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, book_Book_ManagerGetUserBooksCount, arg.AuthorUserID, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const book_GetChapterOrder = `-- name: Book_GetChapterOrder :many
select "order", id
from book_chapters
where book_id = $1
order by "order"
`

type Book_GetChapterOrderRow struct {
	Order int32
	ID    int64
}

func (q *Queries) Book_GetChapterOrder(ctx context.Context, bookID int64) ([]Book_GetChapterOrderRow, error) {
	rows, err := q.db.Query(ctx, book_GetChapterOrder, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book_GetChapterOrderRow
	for rows.Next() {
		var i Book_GetChapterOrderRow
		if err := rows.Scan(&i.Order, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const book_GetLastChapterOrder = `-- name: Book_GetLastChapterOrder :one
select cast(coalesce(max("order"), 0) as int4) as last_order
from book_chapters
where book_id = $1
`

func (q *Queries) Book_GetLastChapterOrder(ctx context.Context, bookID int64) (int32, error) {
	row := q.db.QueryRow(ctx, book_GetLastChapterOrder, bookID)
	var last_order int32
	err := row.Scan(&last_order)
	return last_order, err
}

const book_Insert = `-- name: Book_Insert :exec
insert into books 
(
    id, name, summary, author_user_id, created_at, age_rating, tag_ids, cached_parent_tag_ids,
    is_publicly_visible, slug
)
values 
(
    $1, $2, $3, $4, $5, $6, $7, $8, 
    $9, $10
)
`

type Book_InsertParams struct {
	ID                 int64
	Name               string
	Summary            string
	AuthorUserID       pgtype.UUID
	CreatedAt          pgtype.Timestamptz
	AgeRating          AgeRating
	TagIds             []int64
	CachedParentTagIds []int64
	IsPubliclyVisible  bool
	Slug               string
}

func (q *Queries) Book_Insert(ctx context.Context, arg Book_InsertParams) error {
	_, err := q.db.Exec(ctx, book_Insert,
		arg.ID,
		arg.Name,
		arg.Summary,
		arg.AuthorUserID,
		arg.CreatedAt,
		arg.AgeRating,
		arg.TagIds,
		arg.CachedParentTagIds,
		arg.IsPubliclyVisible,
		arg.Slug,
	)
	return err
}

const book_InsertChapter = `-- name: Book_InsertChapter :exec
insert into book_chapters
(id, name, book_id, content, "order", created_at, words, summary, is_publicly_visible)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type Book_InsertChapterParams struct {
	ID                int64
	Name              string
	BookID            int64
	Content           string
	Order             int32
	CreatedAt         pgtype.Timestamptz
	Words             int32
	Summary           string
	IsPubliclyVisible bool
}

func (q *Queries) Book_InsertChapter(ctx context.Context, arg Book_InsertChapterParams) error {
	_, err := q.db.Exec(ctx, book_InsertChapter,
		arg.ID,
		arg.Name,
		arg.BookID,
		arg.Content,
		arg.Order,
		arg.CreatedAt,
		arg.Words,
		arg.Summary,
		arg.IsPubliclyVisible,
	)
	return err
}

const book_ManagerGetUserBooks = `-- name: Book_ManagerGetUserBooks :many
select 
    books.id, books.name, books.slug, books.summary, books.author_user_id, books.created_at, books.age_rating, books.is_publicly_visible, books.is_banned, books.is_trashed, books.words, books.chapters, books.tag_ids, books.cached_parent_tag_ids, books.cover, books.view, books.rating, books.total_reviews, books.total_ratings, books.is_pinned, books.is_perm_removed, books.is_shadow_banned,
    collections.id as collection_id,
    collections.name as collection_name,
    collection_books."order" as collection_position,
    collections.books_count as collection_size
from books
left join collection_books on books.id = collection_books.book_id
left join collections on collection_books.collection_id = collections.id
where author_user_id = $3 and ($4::text = '' or position(lower($4::text) in lower(books.name)) > 0)
order by books.created_at desc
limit $1 offset $2
`

type Book_ManagerGetUserBooksParams struct {
	Limit        int32
	Offset       int32
	AuthorUserID pgtype.UUID
	Search       string
}

type Book_ManagerGetUserBooksRow struct {
	ID                 int64
	Name               string
	Slug               string
	Summary            string
	AuthorUserID       pgtype.UUID
	CreatedAt          pgtype.Timestamptz
	AgeRating          AgeRating
	IsPubliclyVisible  bool
	IsBanned           bool
	IsTrashed          bool
	Words              int32
	Chapters           int32
	TagIds             []int64
	CachedParentTagIds []int64
	Cover              string
	View               int32
	Rating             pgtype.Float8
	TotalReviews       int32
	TotalRatings       int32
	IsPinned           bool
	IsPermRemoved      bool
	IsShadowBanned     bool
	CollectionID       pgtype.Int8
	CollectionName     pgtype.Text
	CollectionPosition pgtype.Int4
	CollectionSize     pgtype.Int4
}

func (q *Queries) Book_ManagerGetUserBooks(ctx context.Context, arg Book_ManagerGetUserBooksParams) ([]Book_ManagerGetUserBooksRow, error) {
	rows, err := q.db.Query(ctx, book_ManagerGetUserBooks,
		arg.Limit,
		arg.Offset,
		arg.AuthorUserID,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book_ManagerGetUserBooksRow
	for rows.Next() {
		var i Book_ManagerGetUserBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Summary,
			&i.AuthorUserID,
			&i.CreatedAt,
			&i.AgeRating,
			&i.IsPubliclyVisible,
			&i.IsBanned,
			&i.IsTrashed,
			&i.Words,
			&i.Chapters,
			&i.TagIds,
			&i.CachedParentTagIds,
			&i.Cover,
			&i.View,
			&i.Rating,
			&i.TotalReviews,
			&i.TotalRatings,
			&i.IsPinned,
			&i.IsPermRemoved,
			&i.IsShadowBanned,
			&i.CollectionID,
			&i.CollectionName,
			&i.CollectionPosition,
			&i.CollectionSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const book_SetChapterOrder = `-- name: Book_SetChapterOrder :exec
update book_chapters
set "order" = $2, updated_at = now()
where id = $1
`

type Book_SetChapterOrderParams struct {
	ID    int64
	Order int32
}

func (q *Queries) Book_SetChapterOrder(ctx context.Context, arg Book_SetChapterOrderParams) error {
	_, err := q.db.Exec(ctx, book_SetChapterOrder, arg.ID, arg.Order)
	return err
}

const book_Trash = `-- name: Book_Trash :exec
update books
set is_trashed = true, is_publicly_visible = false
where id = $1
`

func (q *Queries) Book_Trash(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, book_Trash, id)
	return err
}

const book_UnTrash = `-- name: Book_UnTrash :exec
update books
set is_trashed = false, is_publicly_visible = $2
where id = $1
`

type Book_UnTrashParams struct {
	ID                int64
	IsPubliclyVisible bool
}

func (q *Queries) Book_UnTrash(ctx context.Context, arg Book_UnTrashParams) error {
	_, err := q.db.Exec(ctx, book_UnTrash, arg.ID, arg.IsPubliclyVisible)
	return err
}

const getChaptersOrder = `-- name: GetChaptersOrder :many
select id
from book_chapters
where book_id = $1
order by "order"
`

func (q *Queries) GetChaptersOrder(ctx context.Context, bookID int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getChaptersOrder, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recalculateBookStats = `-- name: RecalculateBookStats :exec
update books
set words = coalesce(stat.words, 0), chapters = coalesce(stat.chapters, 0)
from (select sum(words) as words, count(1) as chapters from book_chapters where book_id = $1 and is_publicly_visible = true) as stat
where books.id = $1
`

func (q *Queries) RecalculateBookStats(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, recalculateBookStats, id)
	return err
}

const updateBook = `-- name: UpdateBook :exec
update books
set name = $2, age_rating = $3, tag_ids = $4, cached_parent_tag_ids = $5, summary = $6, is_publicly_visible = $7
where id = $1
`

type UpdateBookParams struct {
	ID                 int64
	Name               string
	AgeRating          AgeRating
	TagIds             []int64
	CachedParentTagIds []int64
	Summary            string
	IsPubliclyVisible  bool
}

func (q *Queries) UpdateBook(ctx context.Context, arg UpdateBookParams) error {
	_, err := q.db.Exec(ctx, updateBook,
		arg.ID,
		arg.Name,
		arg.AgeRating,
		arg.TagIds,
		arg.CachedParentTagIds,
		arg.Summary,
		arg.IsPubliclyVisible,
	)
	return err
}

const updateBookChapter = `-- name: UpdateBookChapter :one
update book_chapters
set name = $2, content = $3, words = $4, summary = $5, is_publicly_visible = $6, updated_at = now()
where id = $1
returning book_chapters.book_id
`

type UpdateBookChapterParams struct {
	ID                int64
	Name              string
	Content           string
	Words             int32
	Summary           string
	IsPubliclyVisible bool
}

func (q *Queries) UpdateBookChapter(ctx context.Context, arg UpdateBookChapterParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateBookChapter,
		arg.ID,
		arg.Name,
		arg.Content,
		arg.Words,
		arg.Summary,
		arg.IsPubliclyVisible,
	)
	var book_id int64
	err := row.Scan(&book_id)
	return book_id, err
}
