// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.user.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteInactive2FADevices = `-- name: DeleteInactive2FADevices :exec
delete
from user_2fa
where not initialized and created_at < $1
`

func (q *Queries) DeleteInactive2FADevices(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteInactive2FADevices, createdAt)
	return err
}

const findUserByUsername = `-- name: FindUserByUsername :one
select id, name, joined_at, password_hash, role, is_banned, avatar_file, about, gender, status, profile_css, enable_profile_css, default_theme, privacy_hide_stats, privacy_hide_favorites, privacy_hide_comments, privacy_hide_email, privacy_allow_searching, show_adult_content, censored_tags, censored_tags_mode
from users
where name = $1
limit 1
`

func (q *Queries) FindUserByUsername(ctx context.Context, name string) (User, error) {
	row := q.db.QueryRow(ctx, findUserByUsername, name)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.JoinedAt,
		&i.PasswordHash,
		&i.Role,
		&i.IsBanned,
		&i.AvatarFile,
		&i.About,
		&i.Gender,
		&i.Status,
		&i.ProfileCss,
		&i.EnableProfileCss,
		&i.DefaultTheme,
		&i.PrivacyHideStats,
		&i.PrivacyHideFavorites,
		&i.PrivacyHideComments,
		&i.PrivacyHideEmail,
		&i.PrivacyAllowSearching,
		&i.ShowAdultContent,
		&i.CensoredTags,
		&i.CensoredTagsMode,
	)
	return i, err
}

const get2FADevices = `-- name: Get2FADevices :many
select id, user_id, type, key, created_at, initialized, active
from user_2fa
where user_id = $1
`

func (q *Queries) Get2FADevices(ctx context.Context, userID pgtype.UUID) ([]User2fa, error) {
	rows, err := q.db.Query(ctx, get2FADevices, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User2fa
	for rows.Next() {
		var i User2fa
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.Key,
			&i.CreatedAt,
			&i.Initialized,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionInfo = `-- name: GetSessionInfo :one
select s.id, s.user_id, s.created_at, s.user_agent, s.ip_address, s.expires_at, s.is_terminated, u.name as user_name, u.joined_at as user_joined_at, u."role" as user_role
from sessions s
join users u on s.user_id = u.id
where s.id = $1
`

type GetSessionInfoRow struct {
	ID           string
	UserID       pgtype.UUID
	CreatedAt    pgtype.Timestamptz
	UserAgent    string
	IpAddress    string
	ExpiresAt    pgtype.Timestamptz
	IsTerminated bool
	UserName     string
	UserJoinedAt pgtype.Timestamptz
	UserRole     UserRole
}

func (q *Queries) GetSessionInfo(ctx context.Context, id string) (GetSessionInfoRow, error) {
	row := q.db.QueryRow(ctx, getSessionInfo, id)
	var i GetSessionInfoRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.UserAgent,
		&i.IpAddress,
		&i.ExpiresAt,
		&i.IsTerminated,
		&i.UserName,
		&i.UserJoinedAt,
		&i.UserRole,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
select id, name, joined_at, password_hash, role, is_banned, avatar_file, about, gender, status, profile_css, enable_profile_css, default_theme, privacy_hide_stats, privacy_hide_favorites, privacy_hide_comments, privacy_hide_email, privacy_allow_searching, show_adult_content, censored_tags, censored_tags_mode
from users
where id = $1
limit 1
`

func (q *Queries) GetUser(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.JoinedAt,
		&i.PasswordHash,
		&i.Role,
		&i.IsBanned,
		&i.AvatarFile,
		&i.About,
		&i.Gender,
		&i.Status,
		&i.ProfileCss,
		&i.EnableProfileCss,
		&i.DefaultTheme,
		&i.PrivacyHideStats,
		&i.PrivacyHideFavorites,
		&i.PrivacyHideComments,
		&i.PrivacyHideEmail,
		&i.PrivacyAllowSearching,
		&i.ShowAdultContent,
		&i.CensoredTags,
		&i.CensoredTagsMode,
	)
	return i, err
}

const getUserAboutSettings = `-- name: GetUserAboutSettings :one
select 
    about,
    gender,
    "status"
from users
where id = $1
`

type GetUserAboutSettingsRow struct {
	About  string
	Gender string
	Status string
}

func (q *Queries) GetUserAboutSettings(ctx context.Context, id pgtype.UUID) (GetUserAboutSettingsRow, error) {
	row := q.db.QueryRow(ctx, getUserAboutSettings, id)
	var i GetUserAboutSettingsRow
	err := row.Scan(&i.About, &i.Gender, &i.Status)
	return i, err
}

const getUserCustomizationSettings = `-- name: GetUserCustomizationSettings :one
select 
    profile_css,
    enable_profile_css,
    default_theme
from users
where id = $1
`

type GetUserCustomizationSettingsRow struct {
	ProfileCss       string
	EnableProfileCss bool
	DefaultTheme     string
}

func (q *Queries) GetUserCustomizationSettings(ctx context.Context, id pgtype.UUID) (GetUserCustomizationSettingsRow, error) {
	row := q.db.QueryRow(ctx, getUserCustomizationSettings, id)
	var i GetUserCustomizationSettingsRow
	err := row.Scan(&i.ProfileCss, &i.EnableProfileCss, &i.DefaultTheme)
	return i, err
}

const getUserModerationSettings = `-- name: GetUserModerationSettings :one
select
    show_adult_content,
    censored_tags,
    censored_tags_mode
from users
where id = $1
`

type GetUserModerationSettingsRow struct {
	ShowAdultContent bool
	CensoredTags     []string
	CensoredTagsMode CensorMode
}

func (q *Queries) GetUserModerationSettings(ctx context.Context, id pgtype.UUID) (GetUserModerationSettingsRow, error) {
	row := q.db.QueryRow(ctx, getUserModerationSettings, id)
	var i GetUserModerationSettingsRow
	err := row.Scan(&i.ShowAdultContent, &i.CensoredTags, &i.CensoredTagsMode)
	return i, err
}

const getUserPrivacySettings = `-- name: GetUserPrivacySettings :one
select
    privacy_hide_stats,
    privacy_hide_favorites,
    privacy_hide_comments,
    privacy_hide_email,
    privacy_allow_searching
from users
where id = $1
`

type GetUserPrivacySettingsRow struct {
	PrivacyHideStats      bool
	PrivacyHideFavorites  bool
	PrivacyHideComments   bool
	PrivacyHideEmail      bool
	PrivacyAllowSearching bool
}

func (q *Queries) GetUserPrivacySettings(ctx context.Context, id pgtype.UUID) (GetUserPrivacySettingsRow, error) {
	row := q.db.QueryRow(ctx, getUserPrivacySettings, id)
	var i GetUserPrivacySettingsRow
	err := row.Scan(
		&i.PrivacyHideStats,
		&i.PrivacyHideFavorites,
		&i.PrivacyHideComments,
		&i.PrivacyHideEmail,
		&i.PrivacyAllowSearching,
	)
	return i, err
}

const getUserSessions = `-- name: GetUserSessions :many
select s.id, s.user_id, s.created_at, s.user_agent, s.ip_address, s.expires_at, s.is_terminated, u.id as user_id, u.name as user_name, u.joined_at as user_joined_at
from sessions s
join users u on s.user_id = u.id
where s.user_id = $1
`

type GetUserSessionsRow struct {
	ID           string
	UserID       pgtype.UUID
	CreatedAt    pgtype.Timestamptz
	UserAgent    string
	IpAddress    string
	ExpiresAt    pgtype.Timestamptz
	IsTerminated bool
	UserID_2     pgtype.UUID
	UserName     string
	UserJoinedAt pgtype.Timestamptz
}

func (q *Queries) GetUserSessions(ctx context.Context, userID pgtype.UUID) ([]GetUserSessionsRow, error) {
	rows, err := q.db.Query(ctx, getUserSessions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserSessionsRow
	for rows.Next() {
		var i GetUserSessionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CreatedAt,
			&i.UserAgent,
			&i.IpAddress,
			&i.ExpiresAt,
			&i.IsTerminated,
			&i.UserID_2,
			&i.UserName,
			&i.UserJoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWithDetails = `-- name: GetUserWithDetails :one
select users.id, users.name, users.joined_at, users.password_hash, users.role, users.is_banned, users.avatar_file, users.about, users.gender, users.status, users.profile_css, users.enable_profile_css, users.default_theme, users.privacy_hide_stats, users.privacy_hide_favorites, users.privacy_hide_comments, users.privacy_hide_email, users.privacy_allow_searching, users.show_adult_content, users.censored_tags, users.censored_tags_mode, 
    (select count(*) from books where author_user_id = users.id and is_publicly_visible and not is_banned) as books_total,
    (select count(*) from favorites where user_id = users.id) as favorites,
    (select count(*) from user_follower where followed_id = users.id) as followers,
    (select count(*) from user_follower where follower_id = users.id) as "following"
from users
where users.id = $1
limit 1
`

type GetUserWithDetailsRow struct {
	ID                    pgtype.UUID
	Name                  string
	JoinedAt              pgtype.Timestamptz
	PasswordHash          string
	Role                  UserRole
	IsBanned              bool
	AvatarFile            pgtype.Text
	About                 string
	Gender                string
	Status                string
	ProfileCss            string
	EnableProfileCss      bool
	DefaultTheme          string
	PrivacyHideStats      bool
	PrivacyHideFavorites  bool
	PrivacyHideComments   bool
	PrivacyHideEmail      bool
	PrivacyAllowSearching bool
	ShowAdultContent      bool
	CensoredTags          []string
	CensoredTagsMode      CensorMode
	BooksTotal            int64
	Favorites             int64
	Followers             int64
	Following             int64
}

func (q *Queries) GetUserWithDetails(ctx context.Context, id pgtype.UUID) (GetUserWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getUserWithDetails, id)
	var i GetUserWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.JoinedAt,
		&i.PasswordHash,
		&i.Role,
		&i.IsBanned,
		&i.AvatarFile,
		&i.About,
		&i.Gender,
		&i.Status,
		&i.ProfileCss,
		&i.EnableProfileCss,
		&i.DefaultTheme,
		&i.PrivacyHideStats,
		&i.PrivacyHideFavorites,
		&i.PrivacyHideComments,
		&i.PrivacyHideEmail,
		&i.PrivacyAllowSearching,
		&i.ShowAdultContent,
		&i.CensoredTags,
		&i.CensoredTagsMode,
		&i.BooksTotal,
		&i.Favorites,
		&i.Followers,
		&i.Following,
	)
	return i, err
}

const insertSession = `-- name: InsertSession :exec
insert into sessions
(id, user_id, created_at, user_agent, ip_address, expires_at)
values ($1, $2, $3, $4, $5, $6)
`

type InsertSessionParams struct {
	ID        string
	UserID    pgtype.UUID
	CreatedAt pgtype.Timestamptz
	UserAgent string
	IpAddress string
	ExpiresAt pgtype.Timestamptz
}

func (q *Queries) InsertSession(ctx context.Context, arg InsertSessionParams) error {
	_, err := q.db.Exec(ctx, insertSession,
		arg.ID,
		arg.UserID,
		arg.CreatedAt,
		arg.UserAgent,
		arg.IpAddress,
		arg.ExpiresAt,
	)
	return err
}

const insertUser = `-- name: InsertUser :exec
insert into users
(id, name, password_hash, joined_at)
values ($1, $2, $3, $4)
`

type InsertUserParams struct {
	ID           pgtype.UUID
	Name         string
	PasswordHash string
	JoinedAt     pgtype.Timestamptz
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) error {
	_, err := q.db.Exec(ctx, insertUser,
		arg.ID,
		arg.Name,
		arg.PasswordHash,
		arg.JoinedAt,
	)
	return err
}

const terminateSession = `-- name: TerminateSession :exec
update sessions
set is_terminated = true
where id = $1
`

func (q *Queries) TerminateSession(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, terminateSession, id)
	return err
}

const terminateSessionsByUserID = `-- name: TerminateSessionsByUserID :exec
update sessions
set is_terminated = true
where user_id = $1
`

func (q *Queries) TerminateSessionsByUserID(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, terminateSessionsByUserID, userID)
	return err
}

const updateUserAboutSettings = `-- name: UpdateUserAboutSettings :exec
update users
set about = $2, gender = $3, "status" = $4
where id = $1
`

type UpdateUserAboutSettingsParams struct {
	ID     pgtype.UUID
	About  string
	Gender string
	Status string
}

func (q *Queries) UpdateUserAboutSettings(ctx context.Context, arg UpdateUserAboutSettingsParams) error {
	_, err := q.db.Exec(ctx, updateUserAboutSettings,
		arg.ID,
		arg.About,
		arg.Gender,
		arg.Status,
	)
	return err
}

const updateUserCustomizationSettings = `-- name: UpdateUserCustomizationSettings :exec
update users
set profile_css = $2, enable_profile_css = $3, default_theme = $4
where id = $1
`

type UpdateUserCustomizationSettingsParams struct {
	ID               pgtype.UUID
	ProfileCss       string
	EnableProfileCss bool
	DefaultTheme     string
}

func (q *Queries) UpdateUserCustomizationSettings(ctx context.Context, arg UpdateUserCustomizationSettingsParams) error {
	_, err := q.db.Exec(ctx, updateUserCustomizationSettings,
		arg.ID,
		arg.ProfileCss,
		arg.EnableProfileCss,
		arg.DefaultTheme,
	)
	return err
}

const updateUserModerationSettings = `-- name: UpdateUserModerationSettings :exec
update users
set show_adult_content = $2,
    censored_tags = $3,
    censored_tags_mode = $4
where id = $1
`

type UpdateUserModerationSettingsParams struct {
	ID               pgtype.UUID
	ShowAdultContent bool
	CensoredTags     []string
	CensoredTagsMode CensorMode
}

func (q *Queries) UpdateUserModerationSettings(ctx context.Context, arg UpdateUserModerationSettingsParams) error {
	_, err := q.db.Exec(ctx, updateUserModerationSettings,
		arg.ID,
		arg.ShowAdultContent,
		arg.CensoredTags,
		arg.CensoredTagsMode,
	)
	return err
}

const updateUserPrivacySettings = `-- name: UpdateUserPrivacySettings :exec
update users
set privacy_hide_stats = $2,
    privacy_hide_favorites = $3,
    privacy_hide_comments = $4,
    privacy_hide_email = $5,
    privacy_allow_searching = $6
where id = $1
`

type UpdateUserPrivacySettingsParams struct {
	ID                    pgtype.UUID
	PrivacyHideStats      bool
	PrivacyHideFavorites  bool
	PrivacyHideComments   bool
	PrivacyHideEmail      bool
	PrivacyAllowSearching bool
}

func (q *Queries) UpdateUserPrivacySettings(ctx context.Context, arg UpdateUserPrivacySettingsParams) error {
	_, err := q.db.Exec(ctx, updateUserPrivacySettings,
		arg.ID,
		arg.PrivacyHideStats,
		arg.PrivacyHideFavorites,
		arg.PrivacyHideComments,
		arg.PrivacyHideEmail,
		arg.PrivacyAllowSearching,
	)
	return err
}

const userExistsByUsername = `-- name: UserExistsByUsername :one
select exists(select 1
from users
where name = $1)
`

func (q *Queries) UserExistsByUsername(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRow(ctx, userExistsByUsername, name)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
