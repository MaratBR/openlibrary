// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.user.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteInactive2FADevices = `-- name: DeleteInactive2FADevices :exec
delete
from user_2fa
where not initialized and created_at < $1
`

func (q *Queries) DeleteInactive2FADevices(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteInactive2FADevices, createdAt)
	return err
}

const deleteUserFollow = `-- name: DeleteUserFollow :exec
delete
from user_follower
where follower_id = $1 and followed_id = $2
`

type DeleteUserFollowParams struct {
	FollowerID pgtype.UUID
	FollowedID pgtype.UUID
}

func (q *Queries) DeleteUserFollow(ctx context.Context, arg DeleteUserFollowParams) error {
	_, err := q.db.Exec(ctx, deleteUserFollow, arg.FollowerID, arg.FollowedID)
	return err
}

const findUserByUsername = `-- name: FindUserByUsername :one
select id, name, joined_at, password_hash, role, is_banned, avatar_file, about, gender, profile_css, enable_profile_css, default_theme, privacy_hide_stats, privacy_hide_comments, privacy_hide_email, privacy_allow_searching, show_adult_content, censored_tags, censored_tags_mode
from users
where name = $1
limit 1
`

func (q *Queries) FindUserByUsername(ctx context.Context, name string) (User, error) {
	row := q.db.QueryRow(ctx, findUserByUsername, name)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.JoinedAt,
		&i.PasswordHash,
		&i.Role,
		&i.IsBanned,
		&i.AvatarFile,
		&i.About,
		&i.Gender,
		&i.ProfileCss,
		&i.EnableProfileCss,
		&i.DefaultTheme,
		&i.PrivacyHideStats,
		&i.PrivacyHideComments,
		&i.PrivacyHideEmail,
		&i.PrivacyAllowSearching,
		&i.ShowAdultContent,
		&i.CensoredTags,
		&i.CensoredTagsMode,
	)
	return i, err
}

const get2FADevices = `-- name: Get2FADevices :many
select id, user_id, type, key, created_at, initialized, active
from user_2fa
where user_id = $1
`

func (q *Queries) Get2FADevices(ctx context.Context, userID pgtype.UUID) ([]User2fa, error) {
	rows, err := q.db.Query(ctx, get2FADevices, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User2fa
	for rows.Next() {
		var i User2fa
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.Key,
			&i.CreatedAt,
			&i.Initialized,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionInfo = `-- name: GetSessionInfo :one
select s.id, s.sid, s.user_id, s.created_at, s.user_agent, s.ip_address, s.expires_at, s.is_terminated, u.name as user_name, u.joined_at as user_joined_at, u."role" as user_role
from sessions s
join users u on s.user_id = u.id
where s.sid = $1
`

type GetSessionInfoRow struct {
	ID           int64
	Sid          string
	UserID       pgtype.UUID
	CreatedAt    pgtype.Timestamptz
	UserAgent    string
	IpAddress    string
	ExpiresAt    pgtype.Timestamptz
	IsTerminated bool
	UserName     string
	UserJoinedAt pgtype.Timestamptz
	UserRole     UserRole
}

func (q *Queries) GetSessionInfo(ctx context.Context, sid string) (GetSessionInfoRow, error) {
	row := q.db.QueryRow(ctx, getSessionInfo, sid)
	var i GetSessionInfoRow
	err := row.Scan(
		&i.ID,
		&i.Sid,
		&i.UserID,
		&i.CreatedAt,
		&i.UserAgent,
		&i.IpAddress,
		&i.ExpiresAt,
		&i.IsTerminated,
		&i.UserName,
		&i.UserJoinedAt,
		&i.UserRole,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
select id, name, joined_at, password_hash, role, is_banned, avatar_file, about, gender, profile_css, enable_profile_css, default_theme, privacy_hide_stats, privacy_hide_comments, privacy_hide_email, privacy_allow_searching, show_adult_content, censored_tags, censored_tags_mode
from users
where id = $1
limit 1
`

func (q *Queries) GetUser(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.JoinedAt,
		&i.PasswordHash,
		&i.Role,
		&i.IsBanned,
		&i.AvatarFile,
		&i.About,
		&i.Gender,
		&i.ProfileCss,
		&i.EnableProfileCss,
		&i.DefaultTheme,
		&i.PrivacyHideStats,
		&i.PrivacyHideComments,
		&i.PrivacyHideEmail,
		&i.PrivacyAllowSearching,
		&i.ShowAdultContent,
		&i.CensoredTags,
		&i.CensoredTagsMode,
	)
	return i, err
}

const getUserAboutSettings = `-- name: GetUserAboutSettings :one
select 
    about,
    gender
from users
where id = $1
`

type GetUserAboutSettingsRow struct {
	About  string
	Gender string
}

func (q *Queries) GetUserAboutSettings(ctx context.Context, id pgtype.UUID) (GetUserAboutSettingsRow, error) {
	row := q.db.QueryRow(ctx, getUserAboutSettings, id)
	var i GetUserAboutSettingsRow
	err := row.Scan(&i.About, &i.Gender)
	return i, err
}

const getUserCustomizationSettings = `-- name: GetUserCustomizationSettings :one
select 
    profile_css,
    enable_profile_css,
    default_theme
from users
where id = $1
`

type GetUserCustomizationSettingsRow struct {
	ProfileCss       string
	EnableProfileCss bool
	DefaultTheme     string
}

func (q *Queries) GetUserCustomizationSettings(ctx context.Context, id pgtype.UUID) (GetUserCustomizationSettingsRow, error) {
	row := q.db.QueryRow(ctx, getUserCustomizationSettings, id)
	var i GetUserCustomizationSettingsRow
	err := row.Scan(&i.ProfileCss, &i.EnableProfileCss, &i.DefaultTheme)
	return i, err
}

const getUserModerationSettings = `-- name: GetUserModerationSettings :one
select
    show_adult_content,
    censored_tags,
    censored_tags_mode
from users
where id = $1
`

type GetUserModerationSettingsRow struct {
	ShowAdultContent bool
	CensoredTags     []string
	CensoredTagsMode CensorMode
}

func (q *Queries) GetUserModerationSettings(ctx context.Context, id pgtype.UUID) (GetUserModerationSettingsRow, error) {
	row := q.db.QueryRow(ctx, getUserModerationSettings, id)
	var i GetUserModerationSettingsRow
	err := row.Scan(&i.ShowAdultContent, &i.CensoredTags, &i.CensoredTagsMode)
	return i, err
}

const getUserNames = `-- name: GetUserNames :many
select name, id
from users
where id = any($1::uuid[])
`

type GetUserNamesRow struct {
	Name string
	ID   pgtype.UUID
}

func (q *Queries) GetUserNames(ctx context.Context, ids []pgtype.UUID) ([]GetUserNamesRow, error) {
	rows, err := q.db.Query(ctx, getUserNames, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserNamesRow
	for rows.Next() {
		var i GetUserNamesRow
		if err := rows.Scan(&i.Name, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPrivacySettings = `-- name: GetUserPrivacySettings :one
select
    privacy_hide_stats,
    privacy_hide_comments,
    privacy_hide_email,
    privacy_allow_searching
from users
where id = $1
`

type GetUserPrivacySettingsRow struct {
	PrivacyHideStats      bool
	PrivacyHideComments   bool
	PrivacyHideEmail      bool
	PrivacyAllowSearching bool
}

func (q *Queries) GetUserPrivacySettings(ctx context.Context, id pgtype.UUID) (GetUserPrivacySettingsRow, error) {
	row := q.db.QueryRow(ctx, getUserPrivacySettings, id)
	var i GetUserPrivacySettingsRow
	err := row.Scan(
		&i.PrivacyHideStats,
		&i.PrivacyHideComments,
		&i.PrivacyHideEmail,
		&i.PrivacyAllowSearching,
	)
	return i, err
}

const getUserSessions = `-- name: GetUserSessions :many
select s.id, s.sid, s.user_id, s.created_at, s.user_agent, s.ip_address, s.expires_at, s.is_terminated, u.id as user_id, u.name as user_name, u.joined_at as user_joined_at
from sessions s
join users u on s.user_id = u.id
where s.user_id = $1
`

type GetUserSessionsRow struct {
	ID           int64
	Sid          string
	UserID       pgtype.UUID
	CreatedAt    pgtype.Timestamptz
	UserAgent    string
	IpAddress    string
	ExpiresAt    pgtype.Timestamptz
	IsTerminated bool
	UserID_2     pgtype.UUID
	UserName     string
	UserJoinedAt pgtype.Timestamptz
}

func (q *Queries) GetUserSessions(ctx context.Context, userID pgtype.UUID) ([]GetUserSessionsRow, error) {
	rows, err := q.db.Query(ctx, getUserSessions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserSessionsRow
	for rows.Next() {
		var i GetUserSessionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Sid,
			&i.UserID,
			&i.CreatedAt,
			&i.UserAgent,
			&i.IpAddress,
			&i.ExpiresAt,
			&i.IsTerminated,
			&i.UserID_2,
			&i.UserName,
			&i.UserJoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWithDetails = `-- name: GetUserWithDetails :one
select 
    users.id, users.name, users.joined_at, users.password_hash, users.role, users.is_banned, users.avatar_file, users.about, users.gender, users.profile_css, users.enable_profile_css, users.default_theme, users.privacy_hide_stats, users.privacy_hide_comments, users.privacy_hide_email, users.privacy_allow_searching, users.show_adult_content, users.censored_tags, users.censored_tags_mode, 
    (select count(*) from books where author_user_id = users.id and is_publicly_visible and not is_banned and chapters > 0) as books_total,
    (select count(*) from user_follower where followed_id = users.id) as followers,
    (select count(*) from user_follower where follower_id = users.id) as "following",
    (user_follower.created_at is not null)::bool as is_following
from users
left join user_follower on user_follower.followed_id = users.id and user_follower.follower_id = $2
where users.id = $1
limit 1
`

type GetUserWithDetailsParams struct {
	ID          pgtype.UUID
	ActorUserID pgtype.UUID
}

type GetUserWithDetailsRow struct {
	ID                    pgtype.UUID
	Name                  string
	JoinedAt              pgtype.Timestamptz
	PasswordHash          string
	Role                  UserRole
	IsBanned              bool
	AvatarFile            pgtype.Text
	About                 string
	Gender                string
	ProfileCss            string
	EnableProfileCss      bool
	DefaultTheme          string
	PrivacyHideStats      bool
	PrivacyHideComments   bool
	PrivacyHideEmail      bool
	PrivacyAllowSearching bool
	ShowAdultContent      bool
	CensoredTags          []string
	CensoredTagsMode      CensorMode
	BooksTotal            int64
	Followers             int64
	Following             int64
	IsFollowing           bool
}

func (q *Queries) GetUserWithDetails(ctx context.Context, arg GetUserWithDetailsParams) (GetUserWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getUserWithDetails, arg.ID, arg.ActorUserID)
	var i GetUserWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.JoinedAt,
		&i.PasswordHash,
		&i.Role,
		&i.IsBanned,
		&i.AvatarFile,
		&i.About,
		&i.Gender,
		&i.ProfileCss,
		&i.EnableProfileCss,
		&i.DefaultTheme,
		&i.PrivacyHideStats,
		&i.PrivacyHideComments,
		&i.PrivacyHideEmail,
		&i.PrivacyAllowSearching,
		&i.ShowAdultContent,
		&i.CensoredTags,
		&i.CensoredTagsMode,
		&i.BooksTotal,
		&i.Followers,
		&i.Following,
		&i.IsFollowing,
	)
	return i, err
}

const insertSession = `-- name: InsertSession :exec
insert into sessions
(id, sid, user_id, created_at, user_agent, ip_address, expires_at)
values ($1, $2, $3, $4, $5, $6, $7)
`

type InsertSessionParams struct {
	ID        int64
	Sid       string
	UserID    pgtype.UUID
	CreatedAt pgtype.Timestamptz
	UserAgent string
	IpAddress string
	ExpiresAt pgtype.Timestamptz
}

func (q *Queries) InsertSession(ctx context.Context, arg InsertSessionParams) error {
	_, err := q.db.Exec(ctx, insertSession,
		arg.ID,
		arg.Sid,
		arg.UserID,
		arg.CreatedAt,
		arg.UserAgent,
		arg.IpAddress,
		arg.ExpiresAt,
	)
	return err
}

const insertUser = `-- name: InsertUser :exec
insert into users
(id, name, password_hash, joined_at)
values ($1, $2, $3, $4)
`

type InsertUserParams struct {
	ID           pgtype.UUID
	Name         string
	PasswordHash string
	JoinedAt     pgtype.Timestamptz
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) error {
	_, err := q.db.Exec(ctx, insertUser,
		arg.ID,
		arg.Name,
		arg.PasswordHash,
		arg.JoinedAt,
	)
	return err
}

const insertUserFollow = `-- name: InsertUserFollow :exec
insert into user_follower
(follower_id, followed_id)
values ($1, $2)
`

type InsertUserFollowParams struct {
	FollowerID pgtype.UUID
	FollowedID pgtype.UUID
}

func (q *Queries) InsertUserFollow(ctx context.Context, arg InsertUserFollowParams) error {
	_, err := q.db.Exec(ctx, insertUserFollow, arg.FollowerID, arg.FollowedID)
	return err
}

const isFollowing = `-- name: IsFollowing :one
select exists(select 1
from user_follower
where follower_id = $1 and followed_id = $2)
`

type IsFollowingParams struct {
	FollowerID pgtype.UUID
	FollowedID pgtype.UUID
}

func (q *Queries) IsFollowing(ctx context.Context, arg IsFollowingParams) (bool, error) {
	row := q.db.QueryRow(ctx, isFollowing, arg.FollowerID, arg.FollowedID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const terminateSession = `-- name: TerminateSession :exec
update sessions
set is_terminated = true
where sid = $1
`

func (q *Queries) TerminateSession(ctx context.Context, sid string) error {
	_, err := q.db.Exec(ctx, terminateSession, sid)
	return err
}

const terminateSessionsByUserID = `-- name: TerminateSessionsByUserID :exec
update sessions
set is_terminated = true
where user_id = $1
`

func (q *Queries) TerminateSessionsByUserID(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, terminateSessionsByUserID, userID)
	return err
}

const updateUserAboutSettings = `-- name: UpdateUserAboutSettings :exec
update users
set about = $2, gender = $3
where id = $1
`

type UpdateUserAboutSettingsParams struct {
	ID     pgtype.UUID
	About  string
	Gender string
}

func (q *Queries) UpdateUserAboutSettings(ctx context.Context, arg UpdateUserAboutSettingsParams) error {
	_, err := q.db.Exec(ctx, updateUserAboutSettings, arg.ID, arg.About, arg.Gender)
	return err
}

const updateUserCustomizationSettings = `-- name: UpdateUserCustomizationSettings :exec
update users
set profile_css = $2, enable_profile_css = $3, default_theme = $4
where id = $1
`

type UpdateUserCustomizationSettingsParams struct {
	ID               pgtype.UUID
	ProfileCss       string
	EnableProfileCss bool
	DefaultTheme     string
}

func (q *Queries) UpdateUserCustomizationSettings(ctx context.Context, arg UpdateUserCustomizationSettingsParams) error {
	_, err := q.db.Exec(ctx, updateUserCustomizationSettings,
		arg.ID,
		arg.ProfileCss,
		arg.EnableProfileCss,
		arg.DefaultTheme,
	)
	return err
}

const updateUserModerationSettings = `-- name: UpdateUserModerationSettings :exec
update users
set show_adult_content = $2,
    censored_tags = $3,
    censored_tags_mode = $4
where id = $1
`

type UpdateUserModerationSettingsParams struct {
	ID               pgtype.UUID
	ShowAdultContent bool
	CensoredTags     []string
	CensoredTagsMode CensorMode
}

func (q *Queries) UpdateUserModerationSettings(ctx context.Context, arg UpdateUserModerationSettingsParams) error {
	_, err := q.db.Exec(ctx, updateUserModerationSettings,
		arg.ID,
		arg.ShowAdultContent,
		arg.CensoredTags,
		arg.CensoredTagsMode,
	)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
update users
set password_hash = $2
where id = $1
`

type UpdateUserPasswordParams struct {
	ID           pgtype.UUID
	PasswordHash string
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.ID, arg.PasswordHash)
	return err
}

const updateUserPrivacySettings = `-- name: UpdateUserPrivacySettings :exec
update users
set privacy_hide_stats = $2,
    privacy_hide_comments = $3,
    privacy_hide_email = $4,
    privacy_allow_searching = $5
where id = $1
`

type UpdateUserPrivacySettingsParams struct {
	ID                    pgtype.UUID
	PrivacyHideStats      bool
	PrivacyHideComments   bool
	PrivacyHideEmail      bool
	PrivacyAllowSearching bool
}

func (q *Queries) UpdateUserPrivacySettings(ctx context.Context, arg UpdateUserPrivacySettingsParams) error {
	_, err := q.db.Exec(ctx, updateUserPrivacySettings,
		arg.ID,
		arg.PrivacyHideStats,
		arg.PrivacyHideComments,
		arg.PrivacyHideEmail,
		arg.PrivacyAllowSearching,
	)
	return err
}

const updateUserRole = `-- name: UpdateUserRole :exec
update users
set "role" = $2
where id = $1
`

type UpdateUserRoleParams struct {
	ID   pgtype.UUID
	Role UserRole
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) error {
	_, err := q.db.Exec(ctx, updateUserRole, arg.ID, arg.Role)
	return err
}

const userExistsByUsername = `-- name: UserExistsByUsername :one
select exists(select 1
from users
where name = $1)
`

func (q *Queries) UserExistsByUsername(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRow(ctx, userExistsByUsername, name)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
