// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.book.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const book_GetFirstChapterID = `-- name: Book_GetFirstChapterID :one
select id
from book_chapters
where book_id = $1
order by "order"
limit 1
`

func (q *Queries) Book_GetFirstChapterID(ctx context.Context, bookID int64) (int64, error) {
	row := q.db.QueryRow(ctx, book_GetFirstChapterID, bookID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getAllBookChapters = `-- name: GetAllBookChapters :many
select c.id, c.name, c.book_id, c.content, c."order", c.created_at, c.words, c.is_adult_override, c.summary, c.is_publicly_visible, 
  cast(coalesce((select id from drafts where drafts.chapter_id = c.id order by created_at desc limit 1), 0) as int8) as latest_draft_id
from book_chapters c
where book_id = $1
order by "order"
`

type GetAllBookChaptersRow struct {
	ID                int64
	Name              string
	BookID            int64
	Content           string
	Order             int32
	CreatedAt         pgtype.Timestamptz
	Words             int32
	IsAdultOverride   bool
	Summary           string
	IsPubliclyVisible bool
	LatestDraftID     int64
}

func (q *Queries) GetAllBookChapters(ctx context.Context, bookID int64) ([]GetAllBookChaptersRow, error) {
	rows, err := q.db.Query(ctx, getAllBookChapters, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllBookChaptersRow
	for rows.Next() {
		var i GetAllBookChaptersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BookID,
			&i.Content,
			&i.Order,
			&i.CreatedAt,
			&i.Words,
			&i.IsAdultOverride,
			&i.Summary,
			&i.IsPubliclyVisible,
			&i.LatestDraftID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllBooks = `-- name: GetAllBooks :many
select id, name, slug, summary, author_user_id, created_at, age_rating, cached_parent_tag_ids, is_publicly_visible, is_trashed, chapters, words
from books
where id > $1
order by id asc
limit $2
`

type GetAllBooksParams struct {
	ID    int64
	Limit int32
}

type GetAllBooksRow struct {
	ID                 int64
	Name               string
	Slug               string
	Summary            string
	AuthorUserID       pgtype.UUID
	CreatedAt          pgtype.Timestamptz
	AgeRating          AgeRating
	CachedParentTagIds []int64
	IsPubliclyVisible  bool
	IsTrashed          bool
	Chapters           int32
	Words              int32
}

func (q *Queries) GetAllBooks(ctx context.Context, arg GetAllBooksParams) ([]GetAllBooksRow, error) {
	rows, err := q.db.Query(ctx, getAllBooks, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllBooksRow
	for rows.Next() {
		var i GetAllBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Summary,
			&i.AuthorUserID,
			&i.CreatedAt,
			&i.AgeRating,
			&i.CachedParentTagIds,
			&i.IsPubliclyVisible,
			&i.IsTrashed,
			&i.Chapters,
			&i.Words,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBook = `-- name: GetBook :one
select books.id, books.name, books.slug, books.summary, books.author_user_id, books.created_at, books.age_rating, books.is_publicly_visible, books.is_banned, books.is_trashed, books.words, books.chapters, books.tag_ids, books.cached_parent_tag_ids, books.cover, books.view, books.rating, books.total_reviews, books.total_ratings, books.is_pinned, books.is_perm_removed, books.is_shadow_banned, users.name as author_name
from books
join users on books.author_user_id = users.id
where books.id = $1
limit 1
`

type GetBookRow struct {
	ID                 int64
	Name               string
	Slug               string
	Summary            string
	AuthorUserID       pgtype.UUID
	CreatedAt          pgtype.Timestamptz
	AgeRating          AgeRating
	IsPubliclyVisible  bool
	IsBanned           bool
	IsTrashed          bool
	Words              int32
	Chapters           int32
	TagIds             []int64
	CachedParentTagIds []int64
	Cover              string
	View               int32
	Rating             pgtype.Float8
	TotalReviews       int32
	TotalRatings       int32
	IsPinned           bool
	IsPermRemoved      bool
	IsShadowBanned     bool
	AuthorName         string
}

func (q *Queries) GetBook(ctx context.Context, id int64) (GetBookRow, error) {
	row := q.db.QueryRow(ctx, getBook, id)
	var i GetBookRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Summary,
		&i.AuthorUserID,
		&i.CreatedAt,
		&i.AgeRating,
		&i.IsPubliclyVisible,
		&i.IsBanned,
		&i.IsTrashed,
		&i.Words,
		&i.Chapters,
		&i.TagIds,
		&i.CachedParentTagIds,
		&i.Cover,
		&i.View,
		&i.Rating,
		&i.TotalReviews,
		&i.TotalRatings,
		&i.IsPinned,
		&i.IsPermRemoved,
		&i.IsShadowBanned,
		&i.AuthorName,
	)
	return i, err
}

const getBookChapterWithDetails = `-- name: GetBookChapterWithDetails :one
select 
    bc.id, bc.name, bc.book_id, bc.content, bc."order", bc.created_at, bc.words, bc.is_adult_override, bc.summary, bc.is_publicly_visible,
    coalesce(prev_chapter.id, 0) as prev_chapter_id,
    coalesce(prev_chapter.name, '') as prev_chapter_name,
    coalesce(next_chapter.id, 0) as next_chapter_id,
    coalesce(next_chapter.name, '') as next_chapter_name
from book_chapters bc
left join lateral (
    select id, name
    from book_chapters
    where book_id = bc.book_id
      and "order" < bc."order"
      and is_publicly_visible = true
    order by "order" desc
    limit 1
) prev_chapter on true
left join lateral (
    select id, name
    from book_chapters
    where book_id = bc.book_id
      and "order" > bc."order"
      and is_publicly_visible = true
    order by "order" asc
    limit 1
) next_chapter on true
where bc.id = $1
  and (bc.book_id = $2 or $2 = 0)
`

type GetBookChapterWithDetailsParams struct {
	ID     int64
	BookID int64
}

type GetBookChapterWithDetailsRow struct {
	ID                int64
	Name              string
	BookID            int64
	Content           string
	Order             int32
	CreatedAt         pgtype.Timestamptz
	Words             int32
	IsAdultOverride   bool
	Summary           string
	IsPubliclyVisible bool
	PrevChapterID     int64
	PrevChapterName   string
	NextChapterID     int64
	NextChapterName   string
}

func (q *Queries) GetBookChapterWithDetails(ctx context.Context, arg GetBookChapterWithDetailsParams) (GetBookChapterWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getBookChapterWithDetails, arg.ID, arg.BookID)
	var i GetBookChapterWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BookID,
		&i.Content,
		&i.Order,
		&i.CreatedAt,
		&i.Words,
		&i.IsAdultOverride,
		&i.Summary,
		&i.IsPubliclyVisible,
		&i.PrevChapterID,
		&i.PrevChapterName,
		&i.NextChapterID,
		&i.NextChapterName,
	)
	return i, err
}

const getBookCollectionData = `-- name: GetBookCollectionData :many
select collections.id, collections.name, collections.books_count as size, collection_books."order" as position, collections.created_at, users.name as user_name, collections.user_id
from collections
join collection_books on collections.id = collection_books.collection_id
join users on collections.user_id = users.id
where collection_books.book_id = $1
order by collections.created_at desc
`

type GetBookCollectionDataRow struct {
	ID        int64
	Name      string
	Size      int32
	Position  int32
	CreatedAt pgtype.Timestamptz
	UserName  string
	UserID    pgtype.UUID
}

func (q *Queries) GetBookCollectionData(ctx context.Context, bookID int64) ([]GetBookCollectionDataRow, error) {
	rows, err := q.db.Query(ctx, getBookCollectionData, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookCollectionDataRow
	for rows.Next() {
		var i GetBookCollectionDataRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Size,
			&i.Position,
			&i.CreatedAt,
			&i.UserName,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookSearchRelatedData = `-- name: GetBookSearchRelatedData :many
select created_at, cover, id
from books
where id = any($1::int8[])
`

type GetBookSearchRelatedDataRow struct {
	CreatedAt pgtype.Timestamptz
	Cover     string
	ID        int64
}

func (q *Queries) GetBookSearchRelatedData(ctx context.Context, ids []int64) ([]GetBookSearchRelatedDataRow, error) {
	rows, err := q.db.Query(ctx, getBookSearchRelatedData, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookSearchRelatedDataRow
	for rows.Next() {
		var i GetBookSearchRelatedDataRow
		if err := rows.Scan(&i.CreatedAt, &i.Cover, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBooksCollectionData = `-- name: GetBooksCollectionData :many
select collections.id, collections.name, collections.books_count as size, collection_books.book_id, collection_books."order" as position, collections.created_at, users.name as user_name, collections.user_id
from collections
join collection_books on collections.id = collection_books.collection_id
join users on collections.user_id = users.id
where collection_books.book_id = ANY($1::int8[])
order by collections.created_at desc
`

type GetBooksCollectionDataRow struct {
	ID        int64
	Name      string
	Size      int32
	BookID    int64
	Position  int32
	CreatedAt pgtype.Timestamptz
	UserName  string
	UserID    pgtype.UUID
}

func (q *Queries) GetBooksCollectionData(ctx context.Context, dollar_1 []int64) ([]GetBooksCollectionDataRow, error) {
	rows, err := q.db.Query(ctx, getBooksCollectionData, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBooksCollectionDataRow
	for rows.Next() {
		var i GetBooksCollectionDataRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Size,
			&i.BookID,
			&i.Position,
			&i.CreatedAt,
			&i.UserName,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChapterBookID = `-- name: GetChapterBookID :one
select book_id
from book_chapters
where id = $1
`

func (q *Queries) GetChapterBookID(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getChapterBookID, id)
	var book_id int64
	err := row.Scan(&book_id)
	return book_id, err
}

const getPubliclyVisibleBookChapters = `-- name: GetPubliclyVisibleBookChapters :many
select c.id, c.name, c.words, c."order", c.created_at, c.summary, c.is_adult_override
from book_chapters c
where book_id = $1 and is_publicly_visible = true
order by "order"
`

type GetPubliclyVisibleBookChaptersRow struct {
	ID              int64
	Name            string
	Words           int32
	Order           int32
	CreatedAt       pgtype.Timestamptz
	Summary         string
	IsAdultOverride bool
}

func (q *Queries) GetPubliclyVisibleBookChapters(ctx context.Context, bookID int64) ([]GetPubliclyVisibleBookChaptersRow, error) {
	rows, err := q.db.Query(ctx, getPubliclyVisibleBookChapters, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPubliclyVisibleBookChaptersRow
	for rows.Next() {
		var i GetPubliclyVisibleBookChaptersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Words,
			&i.Order,
			&i.CreatedAt,
			&i.Summary,
			&i.IsAdultOverride,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomPublicBookIDs = `-- name: GetRandomPublicBookIDs :many
select id
from books
where is_publicly_visible and age_rating not in ('R', 'NC-17') and not is_banned and chapters > 0
order by random()
limit $1
`

func (q *Queries) GetRandomPublicBookIDs(ctx context.Context, limit int32) ([]int64, error) {
	rows, err := q.db.Query(ctx, getRandomPublicBookIDs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopUserBooks = `-- name: GetTopUserBooks :many
select id, name, slug, summary, author_user_id, created_at, age_rating, is_publicly_visible, is_banned, is_trashed, words, chapters, tag_ids, cached_parent_tag_ids, cover, view, rating, total_reviews, total_ratings, is_pinned, is_perm_removed, is_shadow_banned
from books
where author_user_id = $1 and is_publicly_visible
order by rating desc limit $2
`

type GetTopUserBooksParams struct {
	AuthorUserID pgtype.UUID
	Limit        int32
}

func (q *Queries) GetTopUserBooks(ctx context.Context, arg GetTopUserBooksParams) ([]Book, error) {
	rows, err := q.db.Query(ctx, getTopUserBooks, arg.AuthorUserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Summary,
			&i.AuthorUserID,
			&i.CreatedAt,
			&i.AgeRating,
			&i.IsPubliclyVisible,
			&i.IsBanned,
			&i.IsTrashed,
			&i.Words,
			&i.Chapters,
			&i.TagIds,
			&i.CachedParentTagIds,
			&i.Cover,
			&i.View,
			&i.Rating,
			&i.TotalReviews,
			&i.TotalRatings,
			&i.IsPinned,
			&i.IsPermRemoved,
			&i.IsShadowBanned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBooks = `-- name: GetUserBooks :many
select b.id, b.name, b.slug, b.summary, b.author_user_id, b.created_at, b.age_rating, b.is_publicly_visible, b.is_banned, b.is_trashed, b.words, b.chapters, b.tag_ids, b.cached_parent_tag_ids, b.cover, b.view, b.rating, b.total_reviews, b.total_ratings, b.is_pinned, b.is_perm_removed, b.is_shadow_banned
from books b
where b.author_user_id = $1 and chapters > 0
order by b.is_pinned desc, b.created_at asc
limit $2 offset $3
`

type GetUserBooksParams struct {
	AuthorUserID pgtype.UUID
	Limit        int32
	Offset       int32
}

func (q *Queries) GetUserBooks(ctx context.Context, arg GetUserBooksParams) ([]Book, error) {
	rows, err := q.db.Query(ctx, getUserBooks, arg.AuthorUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Summary,
			&i.AuthorUserID,
			&i.CreatedAt,
			&i.AgeRating,
			&i.IsPubliclyVisible,
			&i.IsBanned,
			&i.IsTrashed,
			&i.Words,
			&i.Chapters,
			&i.TagIds,
			&i.CachedParentTagIds,
			&i.Cover,
			&i.View,
			&i.Rating,
			&i.TotalReviews,
			&i.TotalRatings,
			&i.IsPinned,
			&i.IsPermRemoved,
			&i.IsShadowBanned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
