// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.comments.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const getChapterComments = `-- name: GetChapterComments :many
select comments.id, comments.chapter_id, comments.user_id, comments.content, comments.created_at, comments.updated_at, comments.deleted_at, comments.parent_id, comments.subcomments, users.name as user_name
from comments
join users on comments.user_id = users.id
where chapter_id = $1 and parent_id is null
order by created_at desc
limit $2
`

type GetChapterCommentsParams struct {
	ChapterID int64
	Limit     int32
}

type GetChapterCommentsRow struct {
	ID          int64
	ChapterID   int64
	UserID      pgtype.UUID
	Content     string
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
	ParentID    pgtype.Int8
	Subcomments int32
	UserName    string
}

func (q *Queries) GetChapterComments(ctx context.Context, arg GetChapterCommentsParams) ([]GetChapterCommentsRow, error) {
	rows, err := q.db.Query(ctx, getChapterComments, arg.ChapterID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChapterCommentsRow
	for rows.Next() {
		var i GetChapterCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.ChapterID,
			&i.UserID,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ParentID,
			&i.Subcomments,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChapterCommentsAfter = `-- name: GetChapterCommentsAfter :many
select comments.id, comments.chapter_id, comments.user_id, comments.content, comments.created_at, comments.updated_at, comments.deleted_at, comments.parent_id, comments.subcomments, users.name as user_name
from comments
join users on comments.user_id = users.id
where chapter_id = $1 and parent_id is null and created_at < $3
order by created_at desc
limit $2
`

type GetChapterCommentsAfterParams struct {
	ChapterID int64
	Limit     int32
	CreatedAt pgtype.Timestamptz
}

type GetChapterCommentsAfterRow struct {
	ID          int64
	ChapterID   int64
	UserID      pgtype.UUID
	Content     string
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
	ParentID    pgtype.Int8
	Subcomments int32
	UserName    string
}

func (q *Queries) GetChapterCommentsAfter(ctx context.Context, arg GetChapterCommentsAfterParams) ([]GetChapterCommentsAfterRow, error) {
	rows, err := q.db.Query(ctx, getChapterCommentsAfter, arg.ChapterID, arg.Limit, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChapterCommentsAfterRow
	for rows.Next() {
		var i GetChapterCommentsAfterRow
		if err := rows.Scan(
			&i.ID,
			&i.ChapterID,
			&i.UserID,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ParentID,
			&i.Subcomments,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChildComments = `-- name: GetChildComments :many
select comments.id, comments.chapter_id, comments.user_id, comments.content, comments.created_at, comments.updated_at, comments.deleted_at, comments.parent_id, comments.subcomments, users.name as user_name
from comments
join users on comments.user_id = users.id
where parent_id = $1
order by created_at desc
limit $2
`

type GetChildCommentsParams struct {
	ParentID pgtype.Int8
	Limit    int32
}

type GetChildCommentsRow struct {
	ID          int64
	ChapterID   int64
	UserID      pgtype.UUID
	Content     string
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
	ParentID    pgtype.Int8
	Subcomments int32
	UserName    string
}

func (q *Queries) GetChildComments(ctx context.Context, arg GetChildCommentsParams) ([]GetChildCommentsRow, error) {
	rows, err := q.db.Query(ctx, getChildComments, arg.ParentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChildCommentsRow
	for rows.Next() {
		var i GetChildCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.ChapterID,
			&i.UserID,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ParentID,
			&i.Subcomments,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChildCommentsAfter = `-- name: GetChildCommentsAfter :many
select comments.id, comments.chapter_id, comments.user_id, comments.content, comments.created_at, comments.updated_at, comments.deleted_at, comments.parent_id, comments.subcomments, users.name as user_name
from comments
join users on comments.user_id = users.id
where parent_id = $1 and created_at < $3
order by created_at desc
limit $2
`

type GetChildCommentsAfterParams struct {
	ParentID  pgtype.Int8
	Limit     int32
	CreatedAt pgtype.Timestamptz
}

type GetChildCommentsAfterRow struct {
	ID          int64
	ChapterID   int64
	UserID      pgtype.UUID
	Content     string
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
	ParentID    pgtype.Int8
	Subcomments int32
	UserName    string
}

func (q *Queries) GetChildCommentsAfter(ctx context.Context, arg GetChildCommentsAfterParams) ([]GetChildCommentsAfterRow, error) {
	rows, err := q.db.Query(ctx, getChildCommentsAfter, arg.ParentID, arg.Limit, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChildCommentsAfterRow
	for rows.Next() {
		var i GetChildCommentsAfterRow
		if err := rows.Scan(
			&i.ID,
			&i.ChapterID,
			&i.UserID,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ParentID,
			&i.Subcomments,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentByID = `-- name: GetCommentByID :one
select id, chapter_id, user_id, content, created_at, updated_at, deleted_at, parent_id, subcomments from comments where id = $1
`

func (q *Queries) GetCommentByID(ctx context.Context, id int64) (Comment, error) {
	row := q.db.QueryRow(ctx, getCommentByID, id)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.ChapterID,
		&i.UserID,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ParentID,
		&i.Subcomments,
	)
	return i, err
}

const getCommentWithUserByID = `-- name: GetCommentWithUserByID :one
select c.id, c.chapter_id, c.user_id, c.content, c.created_at, c.updated_at, c.deleted_at, c.parent_id, c.subcomments, u.name as user_name
from comments c
join users u on c.user_id = u.id
where c.id = $1
`

type GetCommentWithUserByIDRow struct {
	ID          int64
	ChapterID   int64
	UserID      pgtype.UUID
	Content     string
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
	ParentID    pgtype.Int8
	Subcomments int32
	UserName    string
}

func (q *Queries) GetCommentWithUserByID(ctx context.Context, id int64) (GetCommentWithUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getCommentWithUserByID, id)
	var i GetCommentWithUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.ChapterID,
		&i.UserID,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ParentID,
		&i.Subcomments,
		&i.UserName,
	)
	return i, err
}

const insertComment = `-- name: InsertComment :exec
insert into comments (id, chapter_id, parent_id, user_id, content, created_at, updated_at) 
values ($1, $2, $3, $4, $5, now(), now())
`

type InsertCommentParams struct {
	ID        int64
	ChapterID int64
	ParentID  pgtype.Int8
	UserID    pgtype.UUID
	Content   string
}

func (q *Queries) InsertComment(ctx context.Context, arg InsertCommentParams) error {
	_, err := q.db.Exec(ctx, insertComment,
		arg.ID,
		arg.ChapterID,
		arg.ParentID,
		arg.UserID,
		arg.Content,
	)
	return err
}

const recalculateCommentSubcomments = `-- name: RecalculateCommentSubcomments :exec
update comments 
set subcomments = (select count(*) from comments c where c.parent_id = $1)
where id = $1
`

func (q *Queries) RecalculateCommentSubcomments(ctx context.Context, id pgtype.Int8) error {
	_, err := q.db.Exec(ctx, recalculateCommentSubcomments, id)
	return err
}

const updateComment = `-- name: UpdateComment :execresult
update comments set content = $2, updated_at = now() where id = $1
`

type UpdateCommentParams struct {
	ID      int64
	Content string
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateComment, arg.ID, arg.Content)
}
