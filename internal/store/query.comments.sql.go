// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.comments.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const getChapterComments = `-- name: GetChapterComments :many
select comments.id, comments.chapter_id, comments.user_id, comments.content, comments.ts, comments.updated_at, comments.deleted_at, comments.parent_id, comments.quote_content, comments.quote_start_pos, users.name as user_name
from comments
join users on comments.user_id = users.id
where chapter_id = $1 and parent_id is null
order by ts desc
limit $2
`

type GetChapterCommentsParams struct {
	ChapterID int64
	Limit     int32
}

type GetChapterCommentsRow struct {
	ID            int64
	ChapterID     int64
	UserID        pgtype.UUID
	Content       string
	Ts            pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	DeletedAt     pgtype.Timestamptz
	ParentID      pgtype.Int8
	QuoteContent  pgtype.Text
	QuoteStartPos pgtype.Int4
	UserName      string
}

func (q *Queries) GetChapterComments(ctx context.Context, arg GetChapterCommentsParams) ([]GetChapterCommentsRow, error) {
	rows, err := q.db.Query(ctx, getChapterComments, arg.ChapterID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChapterCommentsRow
	for rows.Next() {
		var i GetChapterCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.ChapterID,
			&i.UserID,
			&i.Content,
			&i.Ts,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ParentID,
			&i.QuoteContent,
			&i.QuoteStartPos,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChapterCommentsAfter = `-- name: GetChapterCommentsAfter :many
select comments.id, comments.chapter_id, comments.user_id, comments.content, comments.ts, comments.updated_at, comments.deleted_at, comments.parent_id, comments.quote_content, comments.quote_start_pos, users.name as user_name
from comments
join users on comments.user_id = users.id
where chapter_id = $1 and parent_id is null and ts < $3
order by ts desc
limit $2
`

type GetChapterCommentsAfterParams struct {
	ChapterID int64
	Limit     int32
	Ts        pgtype.Timestamptz
}

type GetChapterCommentsAfterRow struct {
	ID            int64
	ChapterID     int64
	UserID        pgtype.UUID
	Content       string
	Ts            pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	DeletedAt     pgtype.Timestamptz
	ParentID      pgtype.Int8
	QuoteContent  pgtype.Text
	QuoteStartPos pgtype.Int4
	UserName      string
}

func (q *Queries) GetChapterCommentsAfter(ctx context.Context, arg GetChapterCommentsAfterParams) ([]GetChapterCommentsAfterRow, error) {
	rows, err := q.db.Query(ctx, getChapterCommentsAfter, arg.ChapterID, arg.Limit, arg.Ts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChapterCommentsAfterRow
	for rows.Next() {
		var i GetChapterCommentsAfterRow
		if err := rows.Scan(
			&i.ID,
			&i.ChapterID,
			&i.UserID,
			&i.Content,
			&i.Ts,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ParentID,
			&i.QuoteContent,
			&i.QuoteStartPos,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChildComments = `-- name: GetChildComments :many
select comments.id, comments.chapter_id, comments.user_id, comments.content, comments.ts, comments.updated_at, comments.deleted_at, comments.parent_id, comments.quote_content, comments.quote_start_pos, users.name as user_name
from comments
join users on comments.user_id = users.id
where parent_id = $1
order by ts desc
limit $2
`

type GetChildCommentsParams struct {
	ParentID pgtype.Int8
	Limit    int32
}

type GetChildCommentsRow struct {
	ID            int64
	ChapterID     int64
	UserID        pgtype.UUID
	Content       string
	Ts            pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	DeletedAt     pgtype.Timestamptz
	ParentID      pgtype.Int8
	QuoteContent  pgtype.Text
	QuoteStartPos pgtype.Int4
	UserName      string
}

func (q *Queries) GetChildComments(ctx context.Context, arg GetChildCommentsParams) ([]GetChildCommentsRow, error) {
	rows, err := q.db.Query(ctx, getChildComments, arg.ParentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChildCommentsRow
	for rows.Next() {
		var i GetChildCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.ChapterID,
			&i.UserID,
			&i.Content,
			&i.Ts,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ParentID,
			&i.QuoteContent,
			&i.QuoteStartPos,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChildCommentsAfter = `-- name: GetChildCommentsAfter :many
select comments.id, comments.chapter_id, comments.user_id, comments.content, comments.ts, comments.updated_at, comments.deleted_at, comments.parent_id, comments.quote_content, comments.quote_start_pos, users.name as user_name
from comments
join users on comments.user_id = users.id
where parent_id = $1 and ts < $3
order by ts desc
limit $2
`

type GetChildCommentsAfterParams struct {
	ParentID pgtype.Int8
	Limit    int32
	Ts       pgtype.Timestamptz
}

type GetChildCommentsAfterRow struct {
	ID            int64
	ChapterID     int64
	UserID        pgtype.UUID
	Content       string
	Ts            pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	DeletedAt     pgtype.Timestamptz
	ParentID      pgtype.Int8
	QuoteContent  pgtype.Text
	QuoteStartPos pgtype.Int4
	UserName      string
}

func (q *Queries) GetChildCommentsAfter(ctx context.Context, arg GetChildCommentsAfterParams) ([]GetChildCommentsAfterRow, error) {
	rows, err := q.db.Query(ctx, getChildCommentsAfter, arg.ParentID, arg.Limit, arg.Ts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChildCommentsAfterRow
	for rows.Next() {
		var i GetChildCommentsAfterRow
		if err := rows.Scan(
			&i.ID,
			&i.ChapterID,
			&i.UserID,
			&i.Content,
			&i.Ts,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ParentID,
			&i.QuoteContent,
			&i.QuoteStartPos,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentByID = `-- name: GetCommentByID :one
select id, chapter_id, user_id, content, ts, updated_at, deleted_at, parent_id, quote_content, quote_start_pos from comments where id = $1
`

func (q *Queries) GetCommentByID(ctx context.Context, id int64) (Comment, error) {
	row := q.db.QueryRow(ctx, getCommentByID, id)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.ChapterID,
		&i.UserID,
		&i.Content,
		&i.Ts,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ParentID,
		&i.QuoteContent,
		&i.QuoteStartPos,
	)
	return i, err
}

const getCommentWithUserByID = `-- name: GetCommentWithUserByID :one
select c.id, c.chapter_id, c.user_id, c.content, c.ts, c.updated_at, c.deleted_at, c.parent_id, c.quote_content, c.quote_start_pos, u.name as user_name
from comments c
join users u on c.user_id = u.id
where c.id = $1
`

type GetCommentWithUserByIDRow struct {
	ID            int64
	ChapterID     int64
	UserID        pgtype.UUID
	Content       string
	Ts            pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	DeletedAt     pgtype.Timestamptz
	ParentID      pgtype.Int8
	QuoteContent  pgtype.Text
	QuoteStartPos pgtype.Int4
	UserName      string
}

func (q *Queries) GetCommentWithUserByID(ctx context.Context, id int64) (GetCommentWithUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getCommentWithUserByID, id)
	var i GetCommentWithUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.ChapterID,
		&i.UserID,
		&i.Content,
		&i.Ts,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ParentID,
		&i.QuoteContent,
		&i.QuoteStartPos,
		&i.UserName,
	)
	return i, err
}

const insertComment = `-- name: InsertComment :exec
insert into comments (id, chapter_id, parent_id, user_id, content, ts, updated_at, quote_content, quote_start_pos) 
values ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type InsertCommentParams struct {
	ID            int64
	ChapterID     int64
	ParentID      pgtype.Int8
	UserID        pgtype.UUID
	Content       string
	Ts            pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	QuoteContent  pgtype.Text
	QuoteStartPos pgtype.Int4
}

func (q *Queries) InsertComment(ctx context.Context, arg InsertCommentParams) error {
	_, err := q.db.Exec(ctx, insertComment,
		arg.ID,
		arg.ChapterID,
		arg.ParentID,
		arg.UserID,
		arg.Content,
		arg.Ts,
		arg.UpdatedAt,
		arg.QuoteContent,
		arg.QuoteStartPos,
	)
	return err
}

const updateComment = `-- name: UpdateComment :execresult
update comments set content = $2, updated_at = $3, quote_content = $4, quote_start_pos = $5 where id = $1
`

type UpdateCommentParams struct {
	ID            int64
	Content       string
	UpdatedAt     pgtype.Timestamptz
	QuoteContent  pgtype.Text
	QuoteStartPos pgtype.Int4
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateComment,
		arg.ID,
		arg.Content,
		arg.UpdatedAt,
		arg.QuoteContent,
		arg.QuoteStartPos,
	)
}
