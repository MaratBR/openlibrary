// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.book-mod.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const modAddBookLog = `-- name: ModAddBookLog :exec
insert into book_logs (id, "time", book_id, action_type, payload, actor_user_id, reason) values ($1, $2, $3, $4, $5, $6, $7)
`

type ModAddBookLogParams struct {
	ID          int64
	Time        pgtype.Timestamptz
	BookID      int64
	ActionType  BookActionType
	Payload     []byte
	ActorUserID pgtype.UUID
	Reason      string
}

func (q *Queries) ModAddBookLog(ctx context.Context, arg ModAddBookLogParams) error {
	_, err := q.db.Exec(ctx, modAddBookLog,
		arg.ID,
		arg.Time,
		arg.BookID,
		arg.ActionType,
		arg.Payload,
		arg.ActorUserID,
		arg.Reason,
	)
	return err
}

const modCountBookLogFiltered = `-- name: ModCountBookLogFiltered :one
select count(*)
from book_logs
join users on users.id = book_logs.actor_user_id
where 
    book_id = $1 and 
    (action_type = ANY(CAST($2 as book_action_type[])) or $2 is null)
`

type ModCountBookLogFilteredParams struct {
	BookID      int64
	ActionTypes []BookActionType
}

func (q *Queries) ModCountBookLogFiltered(ctx context.Context, arg ModCountBookLogFilteredParams) (int64, error) {
	row := q.db.QueryRow(ctx, modCountBookLogFiltered, arg.BookID, arg.ActionTypes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const modGetBookInfo = `-- name: ModGetBookInfo :one
select is_banned, is_shadow_banned, is_perm_removed, name, summary
from books 
where id = $1
`

type ModGetBookInfoRow struct {
	IsBanned       bool
	IsShadowBanned bool
	IsPermRemoved  bool
	Name           string
	Summary        string
}

func (q *Queries) ModGetBookInfo(ctx context.Context, id int64) (ModGetBookInfoRow, error) {
	row := q.db.QueryRow(ctx, modGetBookInfo, id)
	var i ModGetBookInfoRow
	err := row.Scan(
		&i.IsBanned,
		&i.IsShadowBanned,
		&i.IsPermRemoved,
		&i.Name,
		&i.Summary,
	)
	return i, err
}

const modGetBookLog = `-- name: ModGetBookLog :many
select id, time, book_id, action_type, payload, actor_user_id, reason
from book_logs
where book_id = $1
order by "time" desc
limit $2 offset $3
`

type ModGetBookLogParams struct {
	BookID int64
	Limit  int32
	Offset int32
}

func (q *Queries) ModGetBookLog(ctx context.Context, arg ModGetBookLogParams) ([]BookLog, error) {
	rows, err := q.db.Query(ctx, modGetBookLog, arg.BookID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BookLog
	for rows.Next() {
		var i BookLog
		if err := rows.Scan(
			&i.ID,
			&i.Time,
			&i.BookID,
			&i.ActionType,
			&i.Payload,
			&i.ActorUserID,
			&i.Reason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const modGetBookLogFiltered = `-- name: ModGetBookLogFiltered :many
select book_logs.id, book_logs.time, book_logs.book_id, book_logs.action_type, book_logs.payload, book_logs.actor_user_id, book_logs.reason, users.name as actor_user_name
from book_logs
join users on users.id = book_logs.actor_user_id
where 
    book_id = $1 and 
    (action_type = ANY(CAST($4 as book_action_type[])) or $4 is null)
order by "time" desc
limit $2 offset $3
`

type ModGetBookLogFilteredParams struct {
	BookID      int64
	Limit       int32
	Offset      int32
	ActionTypes []BookActionType
}

type ModGetBookLogFilteredRow struct {
	ID            int64
	Time          pgtype.Timestamptz
	BookID        int64
	ActionType    BookActionType
	Payload       []byte
	ActorUserID   pgtype.UUID
	Reason        string
	ActorUserName string
}

func (q *Queries) ModGetBookLogFiltered(ctx context.Context, arg ModGetBookLogFilteredParams) ([]ModGetBookLogFilteredRow, error) {
	rows, err := q.db.Query(ctx, modGetBookLogFiltered,
		arg.BookID,
		arg.Limit,
		arg.Offset,
		arg.ActionTypes,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ModGetBookLogFilteredRow
	for rows.Next() {
		var i ModGetBookLogFilteredRow
		if err := rows.Scan(
			&i.ID,
			&i.Time,
			&i.BookID,
			&i.ActionType,
			&i.Payload,
			&i.ActorUserID,
			&i.Reason,
			&i.ActorUserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const modGetBookLogOfType = `-- name: ModGetBookLogOfType :many
select id, time, book_id, action_type, payload, actor_user_id, reason
from book_logs
where book_id = $1 and action_type = $4
order by "time" desc
limit $2 offset $3
`

type ModGetBookLogOfTypeParams struct {
	BookID     int64
	Limit      int32
	Offset     int32
	ActionType BookActionType
}

func (q *Queries) ModGetBookLogOfType(ctx context.Context, arg ModGetBookLogOfTypeParams) ([]BookLog, error) {
	rows, err := q.db.Query(ctx, modGetBookLogOfType,
		arg.BookID,
		arg.Limit,
		arg.Offset,
		arg.ActionType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BookLog
	for rows.Next() {
		var i BookLog
		if err := rows.Scan(
			&i.ID,
			&i.Time,
			&i.BookID,
			&i.ActionType,
			&i.Payload,
			&i.ActorUserID,
			&i.Reason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const modGetBookModState = `-- name: ModGetBookModState :one
select id, is_banned, is_shadow_banned
from books
where id = $1
`

type ModGetBookModStateRow struct {
	ID             int64
	IsBanned       bool
	IsShadowBanned bool
}

func (q *Queries) ModGetBookModState(ctx context.Context, id int64) (ModGetBookModStateRow, error) {
	row := q.db.QueryRow(ctx, modGetBookModState, id)
	var i ModGetBookModStateRow
	err := row.Scan(&i.ID, &i.IsBanned, &i.IsShadowBanned)
	return i, err
}

const modPermRemoveBook = `-- name: ModPermRemoveBook :exec
update books
set 
    is_perm_removed = true,
    name = '[DELETED]',
    summary = '',
    created_at = now(),
    updated_at = now(),
    age_rating = '?',
    is_publicly_visible = false,
    words = 0,
    -- chapters = 0,
    tag_ids = '{}',
    cached_parent_tag_ids = '{}',
    has_cover = false,
    view = 0,
    rating = null,
    total_reviews = 0,
    total_ratings = 0,
    is_pinned = false,
    author_user_id = $2
where id = $1
`

type ModPermRemoveBookParams struct {
	ID           int64
	AuthorUserID pgtype.UUID
}

func (q *Queries) ModPermRemoveBook(ctx context.Context, arg ModPermRemoveBookParams) error {
	_, err := q.db.Exec(ctx, modPermRemoveBook, arg.ID, arg.AuthorUserID)
	return err
}

const modSetBookBanned = `-- name: ModSetBookBanned :exec
update books 
set is_banned = $1
where id = $2
`

type ModSetBookBannedParams struct {
	IsBanned bool
	ID       int64
}

func (q *Queries) ModSetBookBanned(ctx context.Context, arg ModSetBookBannedParams) error {
	_, err := q.db.Exec(ctx, modSetBookBanned, arg.IsBanned, arg.ID)
	return err
}

const modSetBookShadowBanned = `-- name: ModSetBookShadowBanned :exec
update books 
set is_shadow_banned = $1
where id = $2
`

type ModSetBookShadowBannedParams struct {
	IsShadowBanned bool
	ID             int64
}

func (q *Queries) ModSetBookShadowBanned(ctx context.Context, arg ModSetBookShadowBannedParams) error {
	_, err := q.db.Exec(ctx, modSetBookShadowBanned, arg.IsShadowBanned, arg.ID)
	return err
}
