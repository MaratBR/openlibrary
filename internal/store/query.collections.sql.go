// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.collections.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addBookToCollection = `-- name: AddBookToCollection :exec
insert into collection_books (book_id, collection_id, "order")
values (
    $1, $2,
    (select coalesce(max("order"), 0) + 1 from collection_books where collection_id = $2)    
)
on conflict (book_id, collection_id) do nothing
`

type AddBookToCollectionParams struct {
	BookID       int64
	CollectionID int64
}

func (q *Queries) AddBookToCollection(ctx context.Context, arg AddBookToCollectionParams) error {
	_, err := q.db.Exec(ctx, addBookToCollection, arg.BookID, arg.CollectionID)
	return err
}

const deleteBookFromCollection = `-- name: DeleteBookFromCollection :exec
delete from collection_books where book_id = $1 and collection_id = $2
`

type DeleteBookFromCollectionParams struct {
	BookID       int64
	CollectionID int64
}

func (q *Queries) DeleteBookFromCollection(ctx context.Context, arg DeleteBookFromCollectionParams) error {
	_, err := q.db.Exec(ctx, deleteBookFromCollection, arg.BookID, arg.CollectionID)
	return err
}

const getBookCollections = `-- name: GetBookCollections :many
select c.id, c.name, c.user_id, c.created_at, c.books_count, c.last_updated_at
from collections c
join collection_books cb on cb.collection_id = c.id
where c.user_id = $1 and cb.book_id = $2
order by last_updated_at desc
`

type GetBookCollectionsParams struct {
	UserID pgtype.UUID
	BookID int64
}

func (q *Queries) GetBookCollections(ctx context.Context, arg GetBookCollectionsParams) ([]Collection, error) {
	rows, err := q.db.Query(ctx, getBookCollections, arg.UserID, arg.BookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.CreatedAt,
			&i.BooksCount,
			&i.LastUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollection = `-- name: GetCollection :one
select id, name, user_id, created_at, books_count, last_updated_at
from collections
where id = $1
`

func (q *Queries) GetCollection(ctx context.Context, id int64) (Collection, error) {
	row := q.db.QueryRow(ctx, getCollection, id)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.CreatedAt,
		&i.BooksCount,
		&i.LastUpdatedAt,
	)
	return i, err
}

const getCollectionBooks = `-- name: GetCollectionBooks :many
select b.id, b.name, b.summary, b.author_user_id, b.created_at, b.age_rating, b.is_publicly_visible, b.is_banned, b.words, b.chapters, b.tag_ids, b.cached_parent_tag_ids, b.has_cover, b.view, b.rating, b.total_reviews, b.total_ratings, b.is_pinned, b.is_perm_removed, b.is_shadow_banned, cb."order" as order_within_collection
from collection_books cb
join books b on b.id = cb.book_id
order by cb."order"
`

type GetCollectionBooksRow struct {
	ID                    int64
	Name                  string
	Summary               string
	AuthorUserID          pgtype.UUID
	CreatedAt             pgtype.Timestamptz
	AgeRating             AgeRating
	IsPubliclyVisible     bool
	IsBanned              bool
	Words                 int32
	Chapters              int32
	TagIds                []int64
	CachedParentTagIds    []int64
	HasCover              bool
	View                  int32
	Rating                pgtype.Float8
	TotalReviews          int32
	TotalRatings          int32
	IsPinned              bool
	IsPermRemoved         bool
	IsShadowBanned        bool
	OrderWithinCollection int32
}

func (q *Queries) GetCollectionBooks(ctx context.Context) ([]GetCollectionBooksRow, error) {
	rows, err := q.db.Query(ctx, getCollectionBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectionBooksRow
	for rows.Next() {
		var i GetCollectionBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Summary,
			&i.AuthorUserID,
			&i.CreatedAt,
			&i.AgeRating,
			&i.IsPubliclyVisible,
			&i.IsBanned,
			&i.Words,
			&i.Chapters,
			&i.TagIds,
			&i.CachedParentTagIds,
			&i.HasCover,
			&i.View,
			&i.Rating,
			&i.TotalReviews,
			&i.TotalRatings,
			&i.IsPinned,
			&i.IsPermRemoved,
			&i.IsShadowBanned,
			&i.OrderWithinCollection,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollections = `-- name: GetCollections :many
select id, name, user_id, created_at, books_count, last_updated_at
from collections
where id = ANY($1::int8[])
`

func (q *Queries) GetCollections(ctx context.Context, dollar_1 []int64) ([]Collection, error) {
	rows, err := q.db.Query(ctx, getCollections, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.CreatedAt,
			&i.BooksCount,
			&i.LastUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestUserCollections = `-- name: GetLatestUserCollections :many
select id, name, user_id, created_at, books_count, last_updated_at
from collections
where user_id = $1
order by last_updated_at desc
limit $2
`

type GetLatestUserCollectionsParams struct {
	UserID pgtype.UUID
	Limit  int32
}

func (q *Queries) GetLatestUserCollections(ctx context.Context, arg GetLatestUserCollectionsParams) ([]Collection, error) {
	rows, err := q.db.Query(ctx, getLatestUserCollections, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.CreatedAt,
			&i.BooksCount,
			&i.LastUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaxOrderInCollection = `-- name: GetMaxOrderInCollection :one
select cast(coalesce(max("order"), -1) as int4)
from collection_books
where collection_id = $1
`

func (q *Queries) GetMaxOrderInCollection(ctx context.Context, collectionID int64) (int32, error) {
	row := q.db.QueryRow(ctx, getMaxOrderInCollection, collectionID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getUserCollections = `-- name: GetUserCollections :many
select id, name, user_id, created_at, books_count, last_updated_at
from collections
where user_id = $3
order by created_at desc
limit $1 offset $2
`

type GetUserCollectionsParams struct {
	Limit  int32
	Offset int32
	UserID pgtype.UUID
}

func (q *Queries) GetUserCollections(ctx context.Context, arg GetUserCollectionsParams) ([]Collection, error) {
	rows, err := q.db.Query(ctx, getUserCollections, arg.Limit, arg.Offset, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.CreatedAt,
			&i.BooksCount,
			&i.LastUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCollection = `-- name: InsertCollection :exec
insert into collections (id, name, user_id)
values ($1, $2, $3)
`

type InsertCollectionParams struct {
	ID     int64
	Name   string
	UserID pgtype.UUID
}

func (q *Queries) InsertCollection(ctx context.Context, arg InsertCollectionParams) error {
	_, err := q.db.Exec(ctx, insertCollection, arg.ID, arg.Name, arg.UserID)
	return err
}
