// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.collections.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const collection_AddBookToCollection = `-- name: Collection_AddBookToCollection :exec
insert into collection_books (book_id, collection_id, "order")
values (
    $1, $2,
    (select coalesce(max("order"), 0) + 1 from collection_books where collection_id = $2)    
)
on conflict (book_id, collection_id) do nothing
`

type Collection_AddBookToCollectionParams struct {
	BookID       int64
	CollectionID int64
}

func (q *Queries) Collection_AddBookToCollection(ctx context.Context, arg Collection_AddBookToCollectionParams) error {
	_, err := q.db.Exec(ctx, collection_AddBookToCollection, arg.BookID, arg.CollectionID)
	return err
}

const collection_DeleteBookFromCollection = `-- name: Collection_DeleteBookFromCollection :exec
delete from collection_books where book_id = $1 and collection_id = $2
`

type Collection_DeleteBookFromCollectionParams struct {
	BookID       int64
	CollectionID int64
}

func (q *Queries) Collection_DeleteBookFromCollection(ctx context.Context, arg Collection_DeleteBookFromCollectionParams) error {
	_, err := q.db.Exec(ctx, collection_DeleteBookFromCollection, arg.BookID, arg.CollectionID)
	return err
}

const collection_Get = `-- name: Collection_Get :one
select c.id, c.name, c.slug, c.user_id, c.created_at, c.books_count, c.last_updated_at, u.name as user_name
from collections c
join users u on c.user_id = u.id
where c.id = $1
`

type Collection_GetRow struct {
	ID            int64
	Name          string
	Slug          string
	UserID        pgtype.UUID
	CreatedAt     pgtype.Timestamptz
	BooksCount    int32
	LastUpdatedAt pgtype.Timestamptz
	UserName      string
}

func (q *Queries) Collection_Get(ctx context.Context, id int64) (Collection_GetRow, error) {
	row := q.db.QueryRow(ctx, collection_Get, id)
	var i Collection_GetRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.UserID,
		&i.CreatedAt,
		&i.BooksCount,
		&i.LastUpdatedAt,
		&i.UserName,
	)
	return i, err
}

const collection_GetBooks = `-- name: Collection_GetBooks :many
select b.id, b.name, b.slug, b.summary, b.author_user_id, b.created_at, b.age_rating, b.is_publicly_visible, b.is_banned, b.words, b.chapters, b.tag_ids, b.cached_parent_tag_ids, b.has_cover, b.view, b.rating, b.total_reviews, b.total_ratings, b.is_pinned, b.is_perm_removed, b.is_shadow_banned, author.name as author_name, cb."order" as order_within_collection
from collection_books cb
join books b on b.id = cb.book_id
join users author on author.id = b.author_user_id
where cb.collection_id = $3
order by cb."order"
limit $1 offset $2
`

type Collection_GetBooksParams struct {
	Limit        int32
	Offset       int32
	CollectionID int64
}

type Collection_GetBooksRow struct {
	ID                    int64
	Name                  string
	Slug                  string
	Summary               string
	AuthorUserID          pgtype.UUID
	CreatedAt             pgtype.Timestamptz
	AgeRating             AgeRating
	IsPubliclyVisible     bool
	IsBanned              bool
	Words                 int32
	Chapters              int32
	TagIds                []int64
	CachedParentTagIds    []int64
	HasCover              bool
	View                  int32
	Rating                pgtype.Float8
	TotalReviews          int32
	TotalRatings          int32
	IsPinned              bool
	IsPermRemoved         bool
	IsShadowBanned        bool
	AuthorName            string
	OrderWithinCollection int32
}

func (q *Queries) Collection_GetBooks(ctx context.Context, arg Collection_GetBooksParams) ([]Collection_GetBooksRow, error) {
	rows, err := q.db.Query(ctx, collection_GetBooks, arg.Limit, arg.Offset, arg.CollectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection_GetBooksRow
	for rows.Next() {
		var i Collection_GetBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Summary,
			&i.AuthorUserID,
			&i.CreatedAt,
			&i.AgeRating,
			&i.IsPubliclyVisible,
			&i.IsBanned,
			&i.Words,
			&i.Chapters,
			&i.TagIds,
			&i.CachedParentTagIds,
			&i.HasCover,
			&i.View,
			&i.Rating,
			&i.TotalReviews,
			&i.TotalRatings,
			&i.IsPinned,
			&i.IsPermRemoved,
			&i.IsShadowBanned,
			&i.AuthorName,
			&i.OrderWithinCollection,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const collection_GetByBook = `-- name: Collection_GetByBook :many
select c.id, c.name, c.slug, c.user_id, c.created_at, c.books_count, c.last_updated_at
from collections c
join collection_books cb on cb.collection_id = c.id
where c.user_id = $1 and cb.book_id = $2
order by last_updated_at desc
`

type Collection_GetByBookParams struct {
	UserID pgtype.UUID
	BookID int64
}

func (q *Queries) Collection_GetByBook(ctx context.Context, arg Collection_GetByBookParams) ([]Collection, error) {
	rows, err := q.db.Query(ctx, collection_GetByBook, arg.UserID, arg.BookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.UserID,
			&i.CreatedAt,
			&i.BooksCount,
			&i.LastUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const collection_GetByUser = `-- name: Collection_GetByUser :many
select id, name, slug, user_id, created_at, books_count, last_updated_at
from collections
where user_id = $3
order by created_at desc
limit $1 offset $2
`

type Collection_GetByUserParams struct {
	Limit  int32
	Offset int32
	UserID pgtype.UUID
}

func (q *Queries) Collection_GetByUser(ctx context.Context, arg Collection_GetByUserParams) ([]Collection, error) {
	rows, err := q.db.Query(ctx, collection_GetByUser, arg.Limit, arg.Offset, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.UserID,
			&i.CreatedAt,
			&i.BooksCount,
			&i.LastUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const collection_GetMaxOrder = `-- name: Collection_GetMaxOrder :one
select cast(coalesce(max("order"), -1) as int4)
from collection_books
where collection_id = $1
`

func (q *Queries) Collection_GetMaxOrder(ctx context.Context, collectionID int64) (int32, error) {
	row := q.db.QueryRow(ctx, collection_GetMaxOrder, collectionID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const collection_GetRecentByUser = `-- name: Collection_GetRecentByUser :many
select id, name, slug, user_id, created_at, books_count, last_updated_at
from collections
where user_id = $1
order by last_updated_at desc
limit $2
`

type Collection_GetRecentByUserParams struct {
	UserID pgtype.UUID
	Limit  int32
}

func (q *Queries) Collection_GetRecentByUser(ctx context.Context, arg Collection_GetRecentByUserParams) ([]Collection, error) {
	rows, err := q.db.Query(ctx, collection_GetRecentByUser, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.UserID,
			&i.CreatedAt,
			&i.BooksCount,
			&i.LastUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const collection_Insert = `-- name: Collection_Insert :exec
insert into collections (id, name, slug, user_id)
values ($1, $2, $3, $4)
`

type Collection_InsertParams struct {
	ID     int64
	Name   string
	Slug   string
	UserID pgtype.UUID
}

func (q *Queries) Collection_Insert(ctx context.Context, arg Collection_InsertParams) error {
	_, err := q.db.Exec(ctx, collection_Insert,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.UserID,
	)
	return err
}

const collection_RecalculateCounter = `-- name: Collection_RecalculateCounter :exec
update collections
set books_count = coalesce((select count(*) from collection_books where collection_id = $1), 0)
where id = $1
`

func (q *Queries) Collection_RecalculateCounter(ctx context.Context, collectionID int64) error {
	_, err := q.db.Exec(ctx, collection_RecalculateCounter, collectionID)
	return err
}

const collections_CountByUser = `-- name: Collections_CountByUser :one
select count(*)
from collections 
where user_id = $1
`

func (q *Queries) Collections_CountByUser(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, collections_CountByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const collections_ListByID = `-- name: Collections_ListByID :many
select id, name, slug, user_id, created_at, books_count, last_updated_at
from collections
where id = ANY($1::int8[])
`

func (q *Queries) Collections_ListByID(ctx context.Context, dollar_1 []int64) ([]Collection, error) {
	rows, err := q.db.Query(ctx, collections_ListByID, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.UserID,
			&i.CreatedAt,
			&i.BooksCount,
			&i.LastUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
