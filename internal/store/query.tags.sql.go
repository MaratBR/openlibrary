// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.tags.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const definedTagsAreInitialized = `-- name: DefinedTagsAreInitialized :one
select exists(select 1 from defined_tags) as initialized
`

func (q *Queries) DefinedTagsAreInitialized(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, definedTagsAreInitialized)
	var initialized bool
	err := row.Scan(&initialized)
	return initialized, err
}

const getTag = `-- name: GetTag :one
select id, name, description, is_spoiler, is_adult, created_at, tag_type, synonym_of, is_default, lowercased_name from defined_tags where id = $1
`

func (q *Queries) GetTag(ctx context.Context, id int64) (DefinedTag, error) {
	row := q.db.QueryRow(ctx, getTag, id)
	var i DefinedTag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsSpoiler,
		&i.IsAdult,
		&i.CreatedAt,
		&i.TagType,
		&i.SynonymOf,
		&i.IsDefault,
		&i.LowercasedName,
	)
	return i, err
}

const getTagParent = `-- name: GetTagParent :one
select t0.id, t0.name, t0.description, t0.is_spoiler, t0.is_adult, t0.created_at, t0.tag_type, t0.synonym_of, t0.is_default, t0.lowercased_name 
from defined_tags t0
where t0.id = (select coalesce(t1.synonym_of, t1.id) from defined_tags t1 where t1.id = $1)
`

func (q *Queries) GetTagParent(ctx context.Context, id int64) (DefinedTag, error) {
	row := q.db.QueryRow(ctx, getTagParent, id)
	var i DefinedTag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsSpoiler,
		&i.IsAdult,
		&i.CreatedAt,
		&i.TagType,
		&i.SynonymOf,
		&i.IsDefault,
		&i.LowercasedName,
	)
	return i, err
}

const getTagsByIds = `-- name: GetTagsByIds :many
select id, name, description, is_spoiler, is_adult, created_at, tag_type, synonym_of, is_default, lowercased_name from defined_tags where id = ANY($1::int8[])
`

func (q *Queries) GetTagsByIds(ctx context.Context, ids []int64) ([]DefinedTag, error) {
	rows, err := q.db.Query(ctx, getTagsByIds, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DefinedTag
	for rows.Next() {
		var i DefinedTag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IsSpoiler,
			&i.IsAdult,
			&i.CreatedAt,
			&i.TagType,
			&i.SynonymOf,
			&i.IsDefault,
			&i.LowercasedName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsByName = `-- name: GetTagsByName :many
select id, name, description, is_spoiler, is_adult, created_at, tag_type, synonym_of, is_default, lowercased_name from defined_tags where name = ANY($1::text[])
`

func (q *Queries) GetTagsByName(ctx context.Context, names []string) ([]DefinedTag, error) {
	rows, err := q.db.Query(ctx, getTagsByName, names)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DefinedTag
	for rows.Next() {
		var i DefinedTag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IsSpoiler,
			&i.IsAdult,
			&i.CreatedAt,
			&i.TagType,
			&i.SynonymOf,
			&i.IsDefault,
			&i.LowercasedName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const importTags = `-- name: ImportTags :exec
insert into defined_tags
(id, name, description, is_spoiler, is_adult, created_at, tag_type, synonym_of, is_default)
select
    id, name, description, is_spoiler, is_adult, created_at, tag_type, synonym_of, true
from jsonb_to_recordset($1::jsonb)
as json_set (
    id int8, 
    name text, 
    description text, 
    is_spoiler boolean, 
    is_adult boolean, 
    created_at timestamptz, 
    tag_type tag_type, 
    synonym_of int8)
where not exists (select 1 from defined_tags where name = json_set.name)
`

func (q *Queries) ImportTags(ctx context.Context, dollar_1 []byte) error {
	_, err := q.db.Exec(ctx, importTags, dollar_1)
	return err
}

const insertDefinedTag = `-- name: InsertDefinedTag :exec
insert into defined_tags
(id, name, description, is_spoiler, is_adult, created_at, tag_type, synonym_of)
values ($1, $2, $3, $4, $5, $6, $7, $8)
`

type InsertDefinedTagParams struct {
	ID          int64
	Name        string
	Description string
	IsSpoiler   bool
	IsAdult     bool
	CreatedAt   pgtype.Timestamptz
	TagType     TagType
	SynonymOf   pgtype.Int8
}

func (q *Queries) InsertDefinedTag(ctx context.Context, arg InsertDefinedTagParams) error {
	_, err := q.db.Exec(ctx, insertDefinedTag,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.IsSpoiler,
		arg.IsAdult,
		arg.CreatedAt,
		arg.TagType,
		arg.SynonymOf,
	)
	return err
}

type InsertDefinedTagEnMasseParams struct {
	ID          int64
	Name        string
	Description string
	IsSpoiler   bool
	IsAdult     bool
	CreatedAt   pgtype.Timestamptz
	TagType     TagType
	SynonymOf   pgtype.Int8
}

const removeUnusedDefaultTags = `-- name: RemoveUnusedDefaultTags :exec
delete from defined_tags d
where 
    d.name <> ANY($1::text[]) and
    d.is_default = true and 
    not exists (select 1 from defined_tags where synonym_of = d.id) and
    not exists (select 1 from books where tag_ids @> array[d.id])
`

func (q *Queries) RemoveUnusedDefaultTags(ctx context.Context, names []string) error {
	_, err := q.db.Exec(ctx, removeUnusedDefaultTags, names)
	return err
}

const searchDefinedTags = `-- name: SearchDefinedTags :many
select id, name, description, is_spoiler, is_adult, created_at, tag_type, synonym_of, is_default, lowercased_name
from defined_tags
where lowercased_name like $1
limit $2
`

type SearchDefinedTagsParams struct {
	LowercasedName string
	Limit          int32
}

func (q *Queries) SearchDefinedTags(ctx context.Context, arg SearchDefinedTagsParams) ([]DefinedTag, error) {
	rows, err := q.db.Query(ctx, searchDefinedTags, arg.LowercasedName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DefinedTag
	for rows.Next() {
		var i DefinedTag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IsSpoiler,
			&i.IsAdult,
			&i.CreatedAt,
			&i.TagType,
			&i.SynonymOf,
			&i.IsDefault,
			&i.LowercasedName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDefinedTagsWithType = `-- name: SearchDefinedTagsWithType :many
select id, name, description, is_spoiler, is_adult, created_at, tag_type, synonym_of, is_default, lowercased_name
from defined_tags
where lowercased_name like $1 and tag_type = $3
limit $2
`

type SearchDefinedTagsWithTypeParams struct {
	LowercasedName string
	Limit          int32
	TagType        TagType
}

func (q *Queries) SearchDefinedTagsWithType(ctx context.Context, arg SearchDefinedTagsWithTypeParams) ([]DefinedTag, error) {
	rows, err := q.db.Query(ctx, searchDefinedTagsWithType, arg.LowercasedName, arg.Limit, arg.TagType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DefinedTag
	for rows.Next() {
		var i DefinedTag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IsSpoiler,
			&i.IsAdult,
			&i.CreatedAt,
			&i.TagType,
			&i.SynonymOf,
			&i.IsDefault,
			&i.LowercasedName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
