// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.reading-list.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getBookReadingListState = `-- name: GetBookReadingListState :one
SELECT user_id, book_id, status, last_accessed_chapter_id, last_updated_at
FROM reading_list
WHERE book_id = $1 and user_id = $2
`

type GetBookReadingListStateParams struct {
	BookID int64
	UserID pgtype.UUID
}

func (q *Queries) GetBookReadingListState(ctx context.Context, arg GetBookReadingListStateParams) (ReadingList, error) {
	row := q.db.QueryRow(ctx, getBookReadingListState, arg.BookID, arg.UserID)
	var i ReadingList
	err := row.Scan(
		&i.UserID,
		&i.BookID,
		&i.Status,
		&i.LastAccessedChapterID,
		&i.LastUpdatedAt,
	)
	return i, err
}

const getFirstChapterID = `-- name: GetFirstChapterID :one
select id
from book_chapters
where book_id = $1 and "order" = 0
`

func (q *Queries) GetFirstChapterID(ctx context.Context, bookID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getFirstChapterID, bookID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getLastChapterID = `-- name: GetLastChapterID :one
select c.id
from book_chapters c
where c.book_id = $1 and "order" = (select max("order") from book_chapters where book_id = $1)
`

func (q *Queries) GetLastChapterID(ctx context.Context, bookID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getLastChapterID, bookID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const setBookReadingListStatus = `-- name: SetBookReadingListStatus :one
INSERT INTO reading_list (book_id, user_id, status, last_accessed_chapter_id)
VALUES ($1, $2, $3, null)
ON CONFLICT (book_id, user_id)
DO UPDATE SET status = $3, last_updated_at = now()
RETURNING user_id, book_id, status, last_accessed_chapter_id, last_updated_at
`

type SetBookReadingListStatusParams struct {
	BookID int64
	UserID pgtype.UUID
	Status ReadingListStatus
}

func (q *Queries) SetBookReadingListStatus(ctx context.Context, arg SetBookReadingListStatusParams) (ReadingList, error) {
	row := q.db.QueryRow(ctx, setBookReadingListStatus, arg.BookID, arg.UserID, arg.Status)
	var i ReadingList
	err := row.Scan(
		&i.UserID,
		&i.BookID,
		&i.Status,
		&i.LastAccessedChapterID,
		&i.LastUpdatedAt,
	)
	return i, err
}

const setBookReadingListStatusAndChapter = `-- name: SetBookReadingListStatusAndChapter :one
INSERT INTO reading_list (book_id, user_id, status, last_accessed_chapter_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT (book_id, user_id)
DO UPDATE SET status = $3, last_accessed_chapter_id = $4, last_updated_at = now()
RETURNING user_id, book_id, status, last_accessed_chapter_id, last_updated_at
`

type SetBookReadingListStatusAndChapterParams struct {
	BookID                int64
	UserID                pgtype.UUID
	Status                ReadingListStatus
	LastAccessedChapterID pgtype.Int8
}

func (q *Queries) SetBookReadingListStatusAndChapter(ctx context.Context, arg SetBookReadingListStatusAndChapterParams) (ReadingList, error) {
	row := q.db.QueryRow(ctx, setBookReadingListStatusAndChapter,
		arg.BookID,
		arg.UserID,
		arg.Status,
		arg.LastAccessedChapterID,
	)
	var i ReadingList
	err := row.Scan(
		&i.UserID,
		&i.BookID,
		&i.Status,
		&i.LastAccessedChapterID,
		&i.LastUpdatedAt,
	)
	return i, err
}
