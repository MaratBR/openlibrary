// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.reading-list.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getBookReadingListState = `-- name: GetBookReadingListState :one
SELECT user_id, book_id, status, last_accessed_chapter_id, last_updated_at
FROM reading_list
WHERE book_id = $1 and user_id = $2
`

type GetBookReadingListStateParams struct {
	BookID int64
	UserID pgtype.UUID
}

func (q *Queries) GetBookReadingListState(ctx context.Context, arg GetBookReadingListStateParams) (ReadingList, error) {
	row := q.db.QueryRow(ctx, getBookReadingListState, arg.BookID, arg.UserID)
	var i ReadingList
	err := row.Scan(
		&i.UserID,
		&i.BookID,
		&i.Status,
		&i.LastAccessedChapterID,
		&i.LastUpdatedAt,
	)
	return i, err
}

const getFirstChapterID = `-- name: GetFirstChapterID :one
select id
from book_chapters
where book_id = $1 and "order" = 0
`

func (q *Queries) GetFirstChapterID(ctx context.Context, bookID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getFirstChapterID, bookID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getLastChapterID = `-- name: GetLastChapterID :one
select c.id
from book_chapters c
where c.book_id = $1 and "order" = (select max("order") from book_chapters where book_id = $1)
`

func (q *Queries) GetLastChapterID(ctx context.Context, bookID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getLastChapterID, bookID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getUserLibrary = `-- name: GetUserLibrary :many
select 
    books.id, books.name, books.has_cover, books.age_rating, 
    reading_list.last_updated_at,
    last_chapter."order" as chapter_order, last_chapter.name as chapter_name, last_chapter.id as chapter_id
from reading_list
join books on reading_list.book_id = books.id
left join book_chapters last_chapter on last_chapter.id = reading_list.last_accessed_chapter_id
where reading_list.user_id = $1 and reading_list.status = $2
order by reading_list.last_updated_at
limit $3
`

type GetUserLibraryParams struct {
	UserID pgtype.UUID
	Status ReadingListStatus
	Limit  int32
}

type GetUserLibraryRow struct {
	ID            int64
	Name          string
	HasCover      bool
	AgeRating     AgeRating
	LastUpdatedAt pgtype.Timestamptz
	ChapterOrder  pgtype.Int4
	ChapterName   pgtype.Text
	ChapterID     pgtype.Int8
}

func (q *Queries) GetUserLibrary(ctx context.Context, arg GetUserLibraryParams) ([]GetUserLibraryRow, error) {
	rows, err := q.db.Query(ctx, getUserLibrary, arg.UserID, arg.Status, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserLibraryRow
	for rows.Next() {
		var i GetUserLibraryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.HasCover,
			&i.AgeRating,
			&i.LastUpdatedAt,
			&i.ChapterOrder,
			&i.ChapterName,
			&i.ChapterID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setBookReadingListStatus = `-- name: SetBookReadingListStatus :one
INSERT INTO reading_list (book_id, user_id, status, last_accessed_chapter_id)
VALUES ($1, $2, $3, null)
ON CONFLICT (book_id, user_id)
DO UPDATE SET status = $3, last_updated_at = now()
RETURNING user_id, book_id, status, last_accessed_chapter_id, last_updated_at
`

type SetBookReadingListStatusParams struct {
	BookID int64
	UserID pgtype.UUID
	Status ReadingListStatus
}

func (q *Queries) SetBookReadingListStatus(ctx context.Context, arg SetBookReadingListStatusParams) (ReadingList, error) {
	row := q.db.QueryRow(ctx, setBookReadingListStatus, arg.BookID, arg.UserID, arg.Status)
	var i ReadingList
	err := row.Scan(
		&i.UserID,
		&i.BookID,
		&i.Status,
		&i.LastAccessedChapterID,
		&i.LastUpdatedAt,
	)
	return i, err
}

const setBookReadingListStatusAndChapter = `-- name: SetBookReadingListStatusAndChapter :one
INSERT INTO reading_list (book_id, user_id, status, last_accessed_chapter_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT (book_id, user_id)
DO UPDATE SET status = $3, last_accessed_chapter_id = $4, last_updated_at = now()
RETURNING user_id, book_id, status, last_accessed_chapter_id, last_updated_at
`

type SetBookReadingListStatusAndChapterParams struct {
	BookID                int64
	UserID                pgtype.UUID
	Status                ReadingListStatus
	LastAccessedChapterID pgtype.Int8
}

func (q *Queries) SetBookReadingListStatusAndChapter(ctx context.Context, arg SetBookReadingListStatusAndChapterParams) (ReadingList, error) {
	row := q.db.QueryRow(ctx, setBookReadingListStatusAndChapter,
		arg.BookID,
		arg.UserID,
		arg.Status,
		arg.LastAccessedChapterID,
	)
	var i ReadingList
	err := row.Scan(
		&i.UserID,
		&i.BookID,
		&i.Status,
		&i.LastAccessedChapterID,
		&i.LastUpdatedAt,
	)
	return i, err
}
