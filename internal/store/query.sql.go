// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const definedTagsAreInitialized = `-- name: DefinedTagsAreInitialized :one
select exists(select 1 from defined_tags) as initialized
`

func (q *Queries) DefinedTagsAreInitialized(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, definedTagsAreInitialized)
	var initialized bool
	err := row.Scan(&initialized)
	return initialized, err
}

const findUserByUsername = `-- name: FindUserByUsername :one
select id, name, joined_at, password_hash
from users
where name = $1
limit 1
`

func (q *Queries) FindUserByUsername(ctx context.Context, name string) (User, error) {
	row := q.db.QueryRow(ctx, findUserByUsername, name)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.JoinedAt,
		&i.PasswordHash,
	)
	return i, err
}

const getBook = `-- name: GetBook :one
select books.id, books.name, books.summary, books.author_user_id, books.created_at, books.age_rating, books.words, books.chapters, books.tag_ids, books.cached_parent_tag_ids, users.name as author_name
from books
join users on books.author_user_id = users.id
where books.id = $1
limit 1
`

type GetBookRow struct {
	ID                 int64
	Name               string
	Summary            string
	AuthorUserID       pgtype.UUID
	CreatedAt          pgtype.Timestamptz
	AgeRating          AgeRating
	Words              int32
	Chapters           int32
	TagIds             []int64
	CachedParentTagIds []int64
	AuthorName         string
}

func (q *Queries) GetBook(ctx context.Context, id int64) (GetBookRow, error) {
	row := q.db.QueryRow(ctx, getBook, id)
	var i GetBookRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Summary,
		&i.AuthorUserID,
		&i.CreatedAt,
		&i.AgeRating,
		&i.Words,
		&i.Chapters,
		&i.TagIds,
		&i.CachedParentTagIds,
		&i.AuthorName,
	)
	return i, err
}

const getBookChapterWithDetails = `-- name: GetBookChapterWithDetails :one
select book_chapters.id, book_chapters.name, book_chapters.book_id, book_chapters.content, book_chapters."order", book_chapters.created_at, book_chapters.words, book_chapters.is_adult_override, book_chapters.summary
from book_chapters
join books on book_chapters.book_id = books.id
join users on users.id = books.author_user_id
where book_chapters.id = $1 and book_chapters.book_id = $2
`

type GetBookChapterWithDetailsParams struct {
	ID     int64
	BookID int64
}

func (q *Queries) GetBookChapterWithDetails(ctx context.Context, arg GetBookChapterWithDetailsParams) (BookChapter, error) {
	row := q.db.QueryRow(ctx, getBookChapterWithDetails, arg.ID, arg.BookID)
	var i BookChapter
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BookID,
		&i.Content,
		&i.Order,
		&i.CreatedAt,
		&i.Words,
		&i.IsAdultOverride,
		&i.Summary,
	)
	return i, err
}

const getBookChapters = `-- name: GetBookChapters :many
select c.id, c.name, c.words, c."order", c.created_at, c.summary
from book_chapters c
where book_id = $1
order by "order"
`

type GetBookChaptersRow struct {
	ID        int64
	Name      string
	Words     int32
	Order     int32
	CreatedAt pgtype.Timestamptz
	Summary   string
}

func (q *Queries) GetBookChapters(ctx context.Context, bookID int64) ([]GetBookChaptersRow, error) {
	rows, err := q.db.Query(ctx, getBookChapters, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookChaptersRow
	for rows.Next() {
		var i GetBookChaptersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Words,
			&i.Order,
			&i.CreatedAt,
			&i.Summary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookChaptersMinimal = `-- name: GetBookChaptersMinimal :many
select id, name
from book_chapters
where book_id = $1
order by "order"
`

type GetBookChaptersMinimalRow struct {
	ID   int64
	Name string
}

func (q *Queries) GetBookChaptersMinimal(ctx context.Context, bookID int64) ([]GetBookChaptersMinimalRow, error) {
	rows, err := q.db.Query(ctx, getBookChaptersMinimal, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookChaptersMinimalRow
	for rows.Next() {
		var i GetBookChaptersMinimalRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookCollections = `-- name: GetBookCollections :many
select collections.id, collections.name, collections.books_count as size, collection_books."order" as position, collections.created_at, users.name as user_name, collections.user_id
from collections
join collection_books on collections.id = collection_books.collection_id
join users on collections.user_id = users.id
where collection_books.book_id = $1
order by collections.created_at desc
`

type GetBookCollectionsRow struct {
	ID        int64
	Name      string
	Size      int32
	Position  int32
	CreatedAt pgtype.Timestamptz
	UserName  string
	UserID    pgtype.UUID
}

func (q *Queries) GetBookCollections(ctx context.Context, bookID int64) ([]GetBookCollectionsRow, error) {
	rows, err := q.db.Query(ctx, getBookCollections, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookCollectionsRow
	for rows.Next() {
		var i GetBookCollectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Size,
			&i.Position,
			&i.CreatedAt,
			&i.UserName,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastChapterOrder = `-- name: GetLastChapterOrder :one
select cast(coalesce(max("order"), 0) as int4) as last_order
from book_chapters
where book_id = $1
`

func (q *Queries) GetLastChapterOrder(ctx context.Context, bookID int64) (int32, error) {
	row := q.db.QueryRow(ctx, getLastChapterOrder, bookID)
	var last_order int32
	err := row.Scan(&last_order)
	return last_order, err
}

const getSessionInfo = `-- name: GetSessionInfo :one
select s.id, s.user_id, s.created_at, s.user_agent, s.ip_address, s.expires_at, u.id as user_id, u.name as user_name, u.joined_at as user_joined_at
from sessions s
join users u on s.user_id = u.id
where s.id = $1
`

type GetSessionInfoRow struct {
	ID           string
	UserID       pgtype.UUID
	CreatedAt    pgtype.Timestamptz
	UserAgent    string
	IpAddress    string
	ExpiresAt    pgtype.Timestamptz
	UserID_2     pgtype.UUID
	UserName     string
	UserJoinedAt pgtype.Timestamptz
}

func (q *Queries) GetSessionInfo(ctx context.Context, id string) (GetSessionInfoRow, error) {
	row := q.db.QueryRow(ctx, getSessionInfo, id)
	var i GetSessionInfoRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.UserAgent,
		&i.IpAddress,
		&i.ExpiresAt,
		&i.UserID_2,
		&i.UserName,
		&i.UserJoinedAt,
	)
	return i, err
}

const getTag = `-- name: GetTag :one
select id, name, description, is_spoiler, is_adult, created_at, tag_type, synonym_of, is_default, lowercased_name from defined_tags where id = $1
`

func (q *Queries) GetTag(ctx context.Context, id int64) (DefinedTag, error) {
	row := q.db.QueryRow(ctx, getTag, id)
	var i DefinedTag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsSpoiler,
		&i.IsAdult,
		&i.CreatedAt,
		&i.TagType,
		&i.SynonymOf,
		&i.IsDefault,
		&i.LowercasedName,
	)
	return i, err
}

const getTagParent = `-- name: GetTagParent :one
select t0.id, t0.name, t0.description, t0.is_spoiler, t0.is_adult, t0.created_at, t0.tag_type, t0.synonym_of, t0.is_default, t0.lowercased_name 
from defined_tags t0
where t0.id = (select coalesce(t1.synonym_of, t1.id) from defined_tags t1 where t1.id = $1)
`

func (q *Queries) GetTagParent(ctx context.Context, id int64) (DefinedTag, error) {
	row := q.db.QueryRow(ctx, getTagParent, id)
	var i DefinedTag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsSpoiler,
		&i.IsAdult,
		&i.CreatedAt,
		&i.TagType,
		&i.SynonymOf,
		&i.IsDefault,
		&i.LowercasedName,
	)
	return i, err
}

const getTagsByIds = `-- name: GetTagsByIds :many
select id, name, description, is_spoiler, is_adult, created_at, tag_type, synonym_of, is_default, lowercased_name from defined_tags where id = ANY($1::int8[])
`

func (q *Queries) GetTagsByIds(ctx context.Context, ids []int64) ([]DefinedTag, error) {
	rows, err := q.db.Query(ctx, getTagsByIds, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DefinedTag
	for rows.Next() {
		var i DefinedTag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IsSpoiler,
			&i.IsAdult,
			&i.CreatedAt,
			&i.TagType,
			&i.SynonymOf,
			&i.IsDefault,
			&i.LowercasedName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsByName = `-- name: GetTagsByName :many
select id, name, description, is_spoiler, is_adult, created_at, tag_type, synonym_of, is_default, lowercased_name from defined_tags where name = ANY($1::text[])
`

func (q *Queries) GetTagsByName(ctx context.Context, names []string) ([]DefinedTag, error) {
	rows, err := q.db.Query(ctx, getTagsByName, names)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DefinedTag
	for rows.Next() {
		var i DefinedTag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IsSpoiler,
			&i.IsAdult,
			&i.CreatedAt,
			&i.TagType,
			&i.SynonymOf,
			&i.IsDefault,
			&i.LowercasedName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
select id, name, joined_at, password_hash
from users
where id = $1
limit 1
`

func (q *Queries) GetUser(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.JoinedAt,
		&i.PasswordHash,
	)
	return i, err
}

const getUserBooks = `-- name: GetUserBooks :many
select 
    books.id, books.name, books.summary, books.author_user_id, books.created_at, books.age_rating, books.words, books.chapters, books.tag_ids, books.cached_parent_tag_ids,
    collections.id as collection_id,
    collections.name as collection_name,
    collection_books."order" as collection_position,
    collections.books_count as collection_size
from books
left join collection_books on books.id = collection_books.book_id
left join collections on collection_books.collection_id = collections.id
where author_user_id = $1
order by books.created_at desc
limit $2 offset $3
`

type GetUserBooksParams struct {
	AuthorUserID pgtype.UUID
	Limit        int32
	Offset       int32
}

type GetUserBooksRow struct {
	ID                 int64
	Name               string
	Summary            string
	AuthorUserID       pgtype.UUID
	CreatedAt          pgtype.Timestamptz
	AgeRating          AgeRating
	Words              int32
	Chapters           int32
	TagIds             []int64
	CachedParentTagIds []int64
	CollectionID       pgtype.Int8
	CollectionName     pgtype.Text
	CollectionPosition pgtype.Int4
	CollectionSize     pgtype.Int4
}

func (q *Queries) GetUserBooks(ctx context.Context, arg GetUserBooksParams) ([]GetUserBooksRow, error) {
	rows, err := q.db.Query(ctx, getUserBooks, arg.AuthorUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserBooksRow
	for rows.Next() {
		var i GetUserBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Summary,
			&i.AuthorUserID,
			&i.CreatedAt,
			&i.AgeRating,
			&i.Words,
			&i.Chapters,
			&i.TagIds,
			&i.CachedParentTagIds,
			&i.CollectionID,
			&i.CollectionName,
			&i.CollectionPosition,
			&i.CollectionSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const importTags = `-- name: ImportTags :exec
insert into defined_tags
(id, name, description, is_spoiler, is_adult, created_at, tag_type, synonym_of, is_default)
select
    id, name, description, is_spoiler, is_adult, created_at, tag_type, synonym_of, true
from jsonb_to_recordset($1::jsonb)
as json_set (
    id int8, 
    name text, 
    description text, 
    is_spoiler boolean, 
    is_adult boolean, 
    created_at timestamptz, 
    tag_type tag_type, 
    synonym_of int8)
where not exists (select 1 from defined_tags where name = json_set.name)
`

func (q *Queries) ImportTags(ctx context.Context, dollar_1 []byte) error {
	_, err := q.db.Exec(ctx, importTags, dollar_1)
	return err
}

const insertBook = `-- name: InsertBook :exec
insert into books 
(id, name, summary, author_user_id, created_at, age_rating, tag_ids, cached_parent_tag_ids)
values ($1, $2, $3, $4, $5, $6, $7, $8)
`

type InsertBookParams struct {
	ID                 int64
	Name               string
	Summary            string
	AuthorUserID       pgtype.UUID
	CreatedAt          pgtype.Timestamptz
	AgeRating          AgeRating
	TagIds             []int64
	CachedParentTagIds []int64
}

func (q *Queries) InsertBook(ctx context.Context, arg InsertBookParams) error {
	_, err := q.db.Exec(ctx, insertBook,
		arg.ID,
		arg.Name,
		arg.Summary,
		arg.AuthorUserID,
		arg.CreatedAt,
		arg.AgeRating,
		arg.TagIds,
		arg.CachedParentTagIds,
	)
	return err
}

const insertBookChapter = `-- name: InsertBookChapter :exec
insert into book_chapters
(id, name, book_id, content, "order", created_at, words, summary)
values ($1, $2, $3, $4, $5, $6, $7, $8)
`

type InsertBookChapterParams struct {
	ID        int64
	Name      string
	BookID    int64
	Content   string
	Order     int32
	CreatedAt pgtype.Timestamptz
	Words     int32
	Summary   string
}

func (q *Queries) InsertBookChapter(ctx context.Context, arg InsertBookChapterParams) error {
	_, err := q.db.Exec(ctx, insertBookChapter,
		arg.ID,
		arg.Name,
		arg.BookID,
		arg.Content,
		arg.Order,
		arg.CreatedAt,
		arg.Words,
		arg.Summary,
	)
	return err
}

const insertDefinedTag = `-- name: InsertDefinedTag :exec
insert into defined_tags
(id, name, description, is_spoiler, is_adult, created_at, tag_type, synonym_of)
values ($1, $2, $3, $4, $5, $6, $7, $8)
`

type InsertDefinedTagParams struct {
	ID          int64
	Name        string
	Description string
	IsSpoiler   bool
	IsAdult     bool
	CreatedAt   pgtype.Timestamptz
	TagType     TagType
	SynonymOf   pgtype.Int8
}

func (q *Queries) InsertDefinedTag(ctx context.Context, arg InsertDefinedTagParams) error {
	_, err := q.db.Exec(ctx, insertDefinedTag,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.IsSpoiler,
		arg.IsAdult,
		arg.CreatedAt,
		arg.TagType,
		arg.SynonymOf,
	)
	return err
}

type InsertDefinedTagEnMasseParams struct {
	ID          int64
	Name        string
	Description string
	IsSpoiler   bool
	IsAdult     bool
	CreatedAt   pgtype.Timestamptz
	TagType     TagType
	SynonymOf   pgtype.Int8
}

const insertSession = `-- name: InsertSession :exec
insert into sessions
(id, user_id, created_at, user_agent, ip_address, expires_at)
values ($1, $2, $3, $4, $5, $6)
`

type InsertSessionParams struct {
	ID        string
	UserID    pgtype.UUID
	CreatedAt pgtype.Timestamptz
	UserAgent string
	IpAddress string
	ExpiresAt pgtype.Timestamptz
}

func (q *Queries) InsertSession(ctx context.Context, arg InsertSessionParams) error {
	_, err := q.db.Exec(ctx, insertSession,
		arg.ID,
		arg.UserID,
		arg.CreatedAt,
		arg.UserAgent,
		arg.IpAddress,
		arg.ExpiresAt,
	)
	return err
}

const insertUser = `-- name: InsertUser :exec
insert into users
(id, name, password_hash, joined_at)
values ($1, $2, $3, $4)
`

type InsertUserParams struct {
	ID           pgtype.UUID
	Name         string
	PasswordHash string
	JoinedAt     pgtype.Timestamptz
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) error {
	_, err := q.db.Exec(ctx, insertUser,
		arg.ID,
		arg.Name,
		arg.PasswordHash,
		arg.JoinedAt,
	)
	return err
}

const recalculateBookStats = `-- name: RecalculateBookStats :exec
update books
set words = stat.words, chapters = stat.chapters
from (select sum(words) as words, count(1) as chapters from book_chapters where book_id = $1) as stat
where books.id = $1
`

func (q *Queries) RecalculateBookStats(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, recalculateBookStats, id)
	return err
}

const removeUnusedDefaultTags = `-- name: RemoveUnusedDefaultTags :exec
delete from defined_tags d
where 
    d.name <> ANY($1::text[]) and
    d.is_default = true and 
    not exists (select 1 from defined_tags where synonym_of = d.id) and
    not exists (select 1 from books where tag_ids @> array[d.id])
`

func (q *Queries) RemoveUnusedDefaultTags(ctx context.Context, names []string) error {
	_, err := q.db.Exec(ctx, removeUnusedDefaultTags, names)
	return err
}

const reorderChapters = `-- name: ReorderChapters :exec
update book_chapters
set "order" = c.new_order
from (values ($1::int[])) as v(arr)
join unnest(v.arr) with ordinality as c (value, new_order)
on c.value = book_chapters.id
where book_chapters.book_id = $2
`

type ReorderChaptersParams struct {
	Column1 []int32
	BookID  int64
}

func (q *Queries) ReorderChapters(ctx context.Context, arg ReorderChaptersParams) error {
	_, err := q.db.Exec(ctx, reorderChapters, arg.Column1, arg.BookID)
	return err
}

const searchDefinedTags = `-- name: SearchDefinedTags :many
select id, name, description, is_spoiler, is_adult, created_at, tag_type, synonym_of, is_default, lowercased_name
from defined_tags
where lowercased_name like $1
limit $2
`

type SearchDefinedTagsParams struct {
	LowercasedName string
	Limit          int32
}

func (q *Queries) SearchDefinedTags(ctx context.Context, arg SearchDefinedTagsParams) ([]DefinedTag, error) {
	rows, err := q.db.Query(ctx, searchDefinedTags, arg.LowercasedName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DefinedTag
	for rows.Next() {
		var i DefinedTag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IsSpoiler,
			&i.IsAdult,
			&i.CreatedAt,
			&i.TagType,
			&i.SynonymOf,
			&i.IsDefault,
			&i.LowercasedName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDefinedTagsWithType = `-- name: SearchDefinedTagsWithType :many
select id, name, description, is_spoiler, is_adult, created_at, tag_type, synonym_of, is_default, lowercased_name
from defined_tags
where lowercased_name like $1 and tag_type = $3
limit $2
`

type SearchDefinedTagsWithTypeParams struct {
	LowercasedName string
	Limit          int32
	TagType        TagType
}

func (q *Queries) SearchDefinedTagsWithType(ctx context.Context, arg SearchDefinedTagsWithTypeParams) ([]DefinedTag, error) {
	rows, err := q.db.Query(ctx, searchDefinedTagsWithType, arg.LowercasedName, arg.Limit, arg.TagType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DefinedTag
	for rows.Next() {
		var i DefinedTag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IsSpoiler,
			&i.IsAdult,
			&i.CreatedAt,
			&i.TagType,
			&i.SynonymOf,
			&i.IsDefault,
			&i.LowercasedName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBook = `-- name: UpdateBook :exec
update books
set name = $2, age_rating = $3, tag_ids = $4, cached_parent_tag_ids = $5, summary = $6
where id = $1
`

type UpdateBookParams struct {
	ID                 int64
	Name               string
	AgeRating          AgeRating
	TagIds             []int64
	CachedParentTagIds []int64
	Summary            string
}

func (q *Queries) UpdateBook(ctx context.Context, arg UpdateBookParams) error {
	_, err := q.db.Exec(ctx, updateBook,
		arg.ID,
		arg.Name,
		arg.AgeRating,
		arg.TagIds,
		arg.CachedParentTagIds,
		arg.Summary,
	)
	return err
}

const updateBookChapter = `-- name: UpdateBookChapter :one
update book_chapters
set name = $2, content = $3, words = $4
where id = $1
returning book_chapters.book_id
`

type UpdateBookChapterParams struct {
	ID      int64
	Name    string
	Content string
	Words   int32
}

func (q *Queries) UpdateBookChapter(ctx context.Context, arg UpdateBookChapterParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateBookChapter,
		arg.ID,
		arg.Name,
		arg.Content,
		arg.Words,
	)
	var book_id int64
	err := row.Scan(&book_id)
	return book_id, err
}

const updateSession = `-- name: UpdateSession :exec
update sessions
set expires_at = $1
where id = $2
`

type UpdateSessionParams struct {
	ExpiresAt pgtype.Timestamptz
	ID        string
}

func (q *Queries) UpdateSession(ctx context.Context, arg UpdateSessionParams) error {
	_, err := q.db.Exec(ctx, updateSession, arg.ExpiresAt, arg.ID)
	return err
}

const userExistsByUsername = `-- name: UserExistsByUsername :one
select exists(select 1
from users
where name = $1)
`

func (q *Queries) UserExistsByUsername(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRow(ctx, userExistsByUsername, name)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
