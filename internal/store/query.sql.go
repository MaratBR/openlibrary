// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const findUserByUsername = `-- name: FindUserByUsername :one
select id, name, joined_at, password_hash
from users
where name = $1
limit 1
`

func (q *Queries) FindUserByUsername(ctx context.Context, name string) (User, error) {
	row := q.db.QueryRow(ctx, findUserByUsername, name)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.JoinedAt,
		&i.PasswordHash,
	)
	return i, err
}

const getBook = `-- name: GetBook :one
select id, name, author_user_id, created_at
from books
where id = $1
limit 1
`

func (q *Queries) GetBook(ctx context.Context, id int64) (Book, error) {
	row := q.db.QueryRow(ctx, getBook, id)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AuthorUserID,
		&i.CreatedAt,
	)
	return i, err
}

const getBookChapters = `-- name: GetBookChapters :many
select id, name, book_id, content, "order", created_at
from book_chapters
where book_id = $1
order by "order"
`

func (q *Queries) GetBookChapters(ctx context.Context, bookID int64) ([]BookChapter, error) {
	rows, err := q.db.Query(ctx, getBookChapters, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BookChapter
	for rows.Next() {
		var i BookChapter
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BookID,
			&i.Content,
			&i.Order,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookChaptersMinimal = `-- name: GetBookChaptersMinimal :many
select id, name
from book_chapters
where book_id = $1
order by "order"
`

type GetBookChaptersMinimalRow struct {
	ID   int64
	Name pgtype.Text
}

func (q *Queries) GetBookChaptersMinimal(ctx context.Context, bookID int64) ([]GetBookChaptersMinimalRow, error) {
	rows, err := q.db.Query(ctx, getBookChaptersMinimal, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookChaptersMinimalRow
	for rows.Next() {
		var i GetBookChaptersMinimalRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
select id, name, joined_at, password_hash
from users
where id = $1
limit 1
`

func (q *Queries) GetUser(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.JoinedAt,
		&i.PasswordHash,
	)
	return i, err
}

const insertBook = `-- name: InsertBook :exec
insert into books 
(id, name, author_user_id, created_at)
values ($1, $2, $3, $4)
`

type InsertBookParams struct {
	ID           int64
	Name         string
	AuthorUserID pgtype.UUID
	CreatedAt    pgtype.Timestamptz
}

func (q *Queries) InsertBook(ctx context.Context, arg InsertBookParams) error {
	_, err := q.db.Exec(ctx, insertBook,
		arg.ID,
		arg.Name,
		arg.AuthorUserID,
		arg.CreatedAt,
	)
	return err
}

const insertBookChapter = `-- name: InsertBookChapter :exec
insert into book_chapters
(id, name, book_id, content, "order", created_at)
values ($1, $2, $3, $4, $5, $6)
`

type InsertBookChapterParams struct {
	ID        int64
	Name      pgtype.Text
	BookID    int64
	Content   string
	Order     int32
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) InsertBookChapter(ctx context.Context, arg InsertBookChapterParams) error {
	_, err := q.db.Exec(ctx, insertBookChapter,
		arg.ID,
		arg.Name,
		arg.BookID,
		arg.Content,
		arg.Order,
		arg.CreatedAt,
	)
	return err
}

const insertSession = `-- name: InsertSession :exec
insert into sessions
(id, user_id, created_at, user_agent, ip_address, expires_at)
values ($1, $2, $3, $4, $5, $6)
`

type InsertSessionParams struct {
	ID        string
	UserID    pgtype.UUID
	CreatedAt pgtype.Timestamptz
	UserAgent string
	IpAddress string
	ExpiresAt pgtype.Timestamptz
}

func (q *Queries) InsertSession(ctx context.Context, arg InsertSessionParams) error {
	_, err := q.db.Exec(ctx, insertSession,
		arg.ID,
		arg.UserID,
		arg.CreatedAt,
		arg.UserAgent,
		arg.IpAddress,
		arg.ExpiresAt,
	)
	return err
}

const insertUser = `-- name: InsertUser :exec
insert into users
(id, name, password_hash, joined_at)
values ($1, $2, $3, $4)
`

type InsertUserParams struct {
	ID           pgtype.UUID
	Name         string
	PasswordHash string
	JoinedAt     pgtype.Timestamptz
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) error {
	_, err := q.db.Exec(ctx, insertUser,
		arg.ID,
		arg.Name,
		arg.PasswordHash,
		arg.JoinedAt,
	)
	return err
}

const updateSession = `-- name: UpdateSession :exec
update sessions
set expires_at = $1
where id = $2
`

type UpdateSessionParams struct {
	ExpiresAt pgtype.Timestamptz
	ID        string
}

func (q *Queries) UpdateSession(ctx context.Context, arg UpdateSessionParams) error {
	_, err := q.db.Exec(ctx, updateSession, arg.ExpiresAt, arg.ID)
	return err
}

const userExistsByUsername = `-- name: UserExistsByUsername :one
select exists(select 1
from users
where name = $1)
`

func (q *Queries) UserExistsByUsername(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRow(ctx, userExistsByUsername, name)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
