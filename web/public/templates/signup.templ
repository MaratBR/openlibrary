package templates

import "github.com/MaratBR/openlibrary/internal/csrf"
import "github.com/MaratBR/openlibrary/internal/i18n"
import "github.com/MaratBR/openlibrary/internal/app"
import "time"

templ SignUp(siteConfig *app.SiteConfig, requireEmail bool) {
    {{
        l := i18n.GetLocalizer(ctx)
    }}

    @htmlLayout(htmlLayoutProps{Title: _t(l, "login.login")}) {
        <div class="p-8 w-screen h-screen flex items-center justify-center bg-secondary">
            <main class="w-[400px] min-h-[450px] bg-card p-4 shadow-lg rounded-sm">
                <div class="flex justify-center select-none">
                    <img class="block dark:hidden" src="/_/embed-assets/logo.svg" />
                    <img class="hidden dark:block" src="/_/embed-assets/logo-dark.svg" />
                </div>

                <form method="post" class="flex flex-col">
                    @csrf.CSRFInputTempl(ctx)
                    {{
                        var islandData struct {
                            PasswordRequirements app.PasswordRequirements
                            PrefilledEmail string
                            PrefilledUsername string
                        }
                        islandData.PasswordRequirements = siteConfig.Get().PasswordRequirements
                        islandDataJSON, _ := templ.JSONString(islandData)
                    }}
                    @i18nExtractKeysByPrefix(l, "login")
                    @i18nExtractKeysByPrefix(l, "signup")
                    @i18nExtractKeysByPrefix(l, "password")
                    <ol-island active="true" name="SignUpForm" src="/_/assets/islands/signup.js" data={islandDataJSON} />
                </form>
            </main>
        </div>
    }
}


templ SignUpEmailVerification(email string, status app.EmailVerificationStatus) {
    {{
        l := i18n.GetLocalizer(ctx)
    }}
    @htmlLayout(htmlLayoutProps{Title: _t(l, "login.login")}) {
        <div class="p-8 w-screen h-screen flex items-center justify-center bg-secondary">
            <main class="w-[400px] min-h-[450px] bg-card p-4 shadow-lg rounded-sm">
                <form method="post" x-data="{
                    code:''
                }">
                    @csrf.CSRFInputTempl(ctx)
                    <h1 class="text-2xl font-medium">
                        { _t(l, "signup.emailVerification.title") }
                    </h1>
                    <p>
                        { _tt(l, "signup.emailVerification.description", map[string]string{
                            "email": email,
                        }) }
                    </p>
                    <div class="mt-4">
                        <input 
                            :value="code" 
                            @input="code=$event.target.value.toUpperCase()" 
                            maxlength="6" 
                            required
                            name="code"
                            autocomplete="off"
                            spellcheck="false"
                            placeholder="______"
                            class="input py-6 text-4xl font-semibold font-mono" style="letter-spacing: 0.3ch;" />
                    </div>
                    @i18nExtractKeys(l, []string{
                        "signup.emailVerification.canResendIn",
                    })
                    <div 
                        if status.CanSendAgainAfter.Valid {
                            data-can-resend-after={ status.CanSendAgainAfter.Value.Format(time.RFC3339) }
                        }
                        x-cloak class="mt-4" x-data="{
                        resending: false,
                        canResendAfter: new Date(),
                        canResend: false,
                        text:'',
                        error:'',
                        __interval: 0,
                        init() {
                            const canResend = this.$root.dataset.canResendAfter;
                            if (!canResend) {
                                this.canResendAfter = new Date(0);
                            } else {
                                this.canResendAfter = new Date(canResend);
                            }
                            this.canResend = new Date() > this.canResendAfter;
                            const update = () => {
                                this.canResend = new Date() > this.canResendAfter;
                                
                                const diff = this.canResendAfter - new Date();
                                const minutes = Math.floor(diff / 60000);
                                const seconds = Math.floor((diff - minutes * 60000) / 1000);
                                this.text = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                            };
                            update();
                            this.__interval = setInterval(update, 500);
                        },
                        destroy() {
                            clearInterval(this.__interval);
                        },
                        resend() {
                            if (this.resending) return;
                            this.resending = true;
                            this.error = ''
                            const delay = window.delay(500);
                            fetch('?act=resend', { method: 'PATCH' })
                                .then(OLAPIResponse.create)
                                .then(async r => {
                                    await delay
                                    return r
                                })
                                .then(resp => {
                                    if (!resp.ok) {
                                        this.error = getErrorMessage(resp)
                                    } else {
                                        this.canResendAfter = new Date(resp.data.canResendAfter);
                                    }
                                })
                                .finally(() => (this.resending = false));
                        }
                    }">
                        <button x-show="canResend"
                            :disabled="resending"
                            @click.prevent="resend()"
                            class="link">
                            { _t(l, "signup.emailVerification.resend") }
                        </button>
                        <p x-show="!canResend" x-text="window._('signup.emailVerification.canResendIn', { text: text })" />
                        <span class="loader" x-show="resending"></span>
                        <p class="error" x-text="error" x-show="!resending && error"></p>
                    </div>
                    <button disabled :disabled="code.length !== 6" class="mt-4 btn btn--lg">
                        { _t(l, "signup.emailVerification.verify") }
                    </button>
                </form>
            </main>
        </div>
    }
}