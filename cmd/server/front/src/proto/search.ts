// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.5.0
//   protoc               v5.28.0
// source: search.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "";

export enum ProtoTagsCategory {
  OTHER = 0,
  REL = 1,
  REL_TYPE = 2,
  FANDOM = 3,
  WARNING = 4,
  UNRECOGNIZED = -1,
}

export function protoTagsCategoryFromJSON(object: any): ProtoTagsCategory {
  switch (object) {
    case 0:
    case "OTHER":
      return ProtoTagsCategory.OTHER;
    case 1:
    case "REL":
      return ProtoTagsCategory.REL;
    case 2:
    case "REL_TYPE":
      return ProtoTagsCategory.REL_TYPE;
    case 3:
    case "FANDOM":
      return ProtoTagsCategory.FANDOM;
    case 4:
    case "WARNING":
      return ProtoTagsCategory.WARNING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProtoTagsCategory.UNRECOGNIZED;
  }
}

export function protoTagsCategoryToJSON(object: ProtoTagsCategory): string {
  switch (object) {
    case ProtoTagsCategory.OTHER:
      return "OTHER";
    case ProtoTagsCategory.REL:
      return "REL";
    case ProtoTagsCategory.REL_TYPE:
      return "REL_TYPE";
    case ProtoTagsCategory.FANDOM:
      return "FANDOM";
    case ProtoTagsCategory.WARNING:
      return "WARNING";
    case ProtoTagsCategory.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ProtoAgeRating {
  UNKNOWN = 0,
  G = 1,
  PG = 2,
  PG13 = 3,
  R = 4,
  NC17 = 5,
  UNRECOGNIZED = -1,
}

export function protoAgeRatingFromJSON(object: any): ProtoAgeRating {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return ProtoAgeRating.UNKNOWN;
    case 1:
    case "G":
      return ProtoAgeRating.G;
    case 2:
    case "PG":
      return ProtoAgeRating.PG;
    case 3:
    case "PG13":
      return ProtoAgeRating.PG13;
    case 4:
    case "R":
      return ProtoAgeRating.R;
    case 5:
    case "NC17":
      return ProtoAgeRating.NC17;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProtoAgeRating.UNRECOGNIZED;
  }
}

export function protoAgeRatingToJSON(object: ProtoAgeRating): string {
  switch (object) {
    case ProtoAgeRating.UNKNOWN:
      return "UNKNOWN";
    case ProtoAgeRating.G:
      return "G";
    case ProtoAgeRating.PG:
      return "PG";
    case ProtoAgeRating.PG13:
      return "PG13";
    case ProtoAgeRating.R:
      return "R";
    case ProtoAgeRating.NC17:
      return "NC17";
    case ProtoAgeRating.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ProtoDefinedTag {
  id: string;
  name: string;
  description: string;
  isAdult: boolean;
  isSpoiler: boolean;
  category: ProtoTagsCategory;
}

export interface ProtoBookSearchItem {
  id: string;
  name: string;
  tagIds: string[];
  cover: string;
  words: number;
  chapters: number;
  favorites: number;
  authorName: string;
  authorId: string;
  ageRating: ProtoAgeRating;
  summary: string;
  createdAt: number;
  updatedAt: number;
}

export interface ProtoSearchResult {
  items: ProtoBookSearchItem[];
  tags: ProtoDefinedTag[];
  totalPages: number;
  took: number;
  page: number;
  cacheKey: string;
  cacheTook: number;
  cacheHit: boolean;
}

function createBaseProtoDefinedTag(): ProtoDefinedTag {
  return { id: "0", name: "", description: "", isAdult: false, isSpoiler: false, category: 0 };
}

export const ProtoDefinedTag: MessageFns<ProtoDefinedTag> = {
  encode(message: ProtoDefinedTag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.isAdult !== false) {
      writer.uint32(32).bool(message.isAdult);
    }
    if (message.isSpoiler !== false) {
      writer.uint32(40).bool(message.isSpoiler);
    }
    if (message.category !== 0) {
      writer.uint32(48).int32(message.category);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoDefinedTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoDefinedTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isAdult = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isSpoiler = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoDefinedTag {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      isAdult: isSet(object.isAdult) ? globalThis.Boolean(object.isAdult) : false,
      isSpoiler: isSet(object.isSpoiler) ? globalThis.Boolean(object.isSpoiler) : false,
      category: isSet(object.category) ? protoTagsCategoryFromJSON(object.category) : 0,
    };
  },

  toJSON(message: ProtoDefinedTag): unknown {
    const obj: any = {};
    if (message.id !== "0") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.isAdult !== false) {
      obj.isAdult = message.isAdult;
    }
    if (message.isSpoiler !== false) {
      obj.isSpoiler = message.isSpoiler;
    }
    if (message.category !== 0) {
      obj.category = protoTagsCategoryToJSON(message.category);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoDefinedTag>, I>>(base?: I): ProtoDefinedTag {
    return ProtoDefinedTag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoDefinedTag>, I>>(object: I): ProtoDefinedTag {
    const message = createBaseProtoDefinedTag();
    message.id = object.id ?? "0";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.isAdult = object.isAdult ?? false;
    message.isSpoiler = object.isSpoiler ?? false;
    message.category = object.category ?? 0;
    return message;
  },
};

function createBaseProtoBookSearchItem(): ProtoBookSearchItem {
  return {
    id: "0",
    name: "",
    tagIds: [],
    cover: "",
    words: 0,
    chapters: 0,
    favorites: 0,
    authorName: "",
    authorId: "",
    ageRating: 0,
    summary: "",
    createdAt: 0,
    updatedAt: 0,
  };
}

export const ProtoBookSearchItem: MessageFns<ProtoBookSearchItem> = {
  encode(message: ProtoBookSearchItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    writer.uint32(26).fork();
    for (const v of message.tagIds) {
      writer.int64(v);
    }
    writer.join();
    if (message.cover !== "") {
      writer.uint32(34).string(message.cover);
    }
    if (message.words !== 0) {
      writer.uint32(40).uint32(message.words);
    }
    if (message.chapters !== 0) {
      writer.uint32(48).uint32(message.chapters);
    }
    if (message.favorites !== 0) {
      writer.uint32(56).uint32(message.favorites);
    }
    if (message.authorName !== "") {
      writer.uint32(66).string(message.authorName);
    }
    if (message.authorId !== "") {
      writer.uint32(74).string(message.authorId);
    }
    if (message.ageRating !== 0) {
      writer.uint32(80).int32(message.ageRating);
    }
    if (message.summary !== "") {
      writer.uint32(90).string(message.summary);
    }
    if (message.createdAt !== 0) {
      writer.uint32(96).uint32(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(104).uint32(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoBookSearchItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoBookSearchItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.tagIds.push(reader.int64().toString());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.tagIds.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cover = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.words = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.chapters = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.favorites = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.authorName = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.authorId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.ageRating = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.summary = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.createdAt = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.updatedAt = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoBookSearchItem {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tagIds: globalThis.Array.isArray(object?.tagIds) ? object.tagIds.map((e: any) => globalThis.String(e)) : [],
      cover: isSet(object.cover) ? globalThis.String(object.cover) : "",
      words: isSet(object.words) ? globalThis.Number(object.words) : 0,
      chapters: isSet(object.chapters) ? globalThis.Number(object.chapters) : 0,
      favorites: isSet(object.favorites) ? globalThis.Number(object.favorites) : 0,
      authorName: isSet(object.authorName) ? globalThis.String(object.authorName) : "",
      authorId: isSet(object.authorId) ? globalThis.String(object.authorId) : "",
      ageRating: isSet(object.ageRating) ? protoAgeRatingFromJSON(object.ageRating) : 0,
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: ProtoBookSearchItem): unknown {
    const obj: any = {};
    if (message.id !== "0") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.tagIds?.length) {
      obj.tagIds = message.tagIds;
    }
    if (message.cover !== "") {
      obj.cover = message.cover;
    }
    if (message.words !== 0) {
      obj.words = Math.round(message.words);
    }
    if (message.chapters !== 0) {
      obj.chapters = Math.round(message.chapters);
    }
    if (message.favorites !== 0) {
      obj.favorites = Math.round(message.favorites);
    }
    if (message.authorName !== "") {
      obj.authorName = message.authorName;
    }
    if (message.authorId !== "") {
      obj.authorId = message.authorId;
    }
    if (message.ageRating !== 0) {
      obj.ageRating = protoAgeRatingToJSON(message.ageRating);
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoBookSearchItem>, I>>(base?: I): ProtoBookSearchItem {
    return ProtoBookSearchItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoBookSearchItem>, I>>(object: I): ProtoBookSearchItem {
    const message = createBaseProtoBookSearchItem();
    message.id = object.id ?? "0";
    message.name = object.name ?? "";
    message.tagIds = object.tagIds?.map((e) => e) || [];
    message.cover = object.cover ?? "";
    message.words = object.words ?? 0;
    message.chapters = object.chapters ?? 0;
    message.favorites = object.favorites ?? 0;
    message.authorName = object.authorName ?? "";
    message.authorId = object.authorId ?? "";
    message.ageRating = object.ageRating ?? 0;
    message.summary = object.summary ?? "";
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseProtoSearchResult(): ProtoSearchResult {
  return { items: [], tags: [], totalPages: 0, took: 0, page: 0, cacheKey: "", cacheTook: 0, cacheHit: false };
}

export const ProtoSearchResult: MessageFns<ProtoSearchResult> = {
  encode(message: ProtoSearchResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      ProtoBookSearchItem.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.tags) {
      ProtoDefinedTag.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.totalPages !== 0) {
      writer.uint32(24).uint32(message.totalPages);
    }
    if (message.took !== 0) {
      writer.uint32(32).uint32(message.took);
    }
    if (message.page !== 0) {
      writer.uint32(40).uint32(message.page);
    }
    if (message.cacheKey !== "") {
      writer.uint32(50).string(message.cacheKey);
    }
    if (message.cacheTook !== 0) {
      writer.uint32(56).uint32(message.cacheTook);
    }
    if (message.cacheHit !== false) {
      writer.uint32(64).bool(message.cacheHit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoSearchResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoSearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(ProtoBookSearchItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tags.push(ProtoDefinedTag.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalPages = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.took = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cacheKey = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.cacheTook = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.cacheHit = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoSearchResult {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => ProtoBookSearchItem.fromJSON(e))
        : [],
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => ProtoDefinedTag.fromJSON(e)) : [],
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
      took: isSet(object.took) ? globalThis.Number(object.took) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      cacheKey: isSet(object.cacheKey) ? globalThis.String(object.cacheKey) : "",
      cacheTook: isSet(object.cacheTook) ? globalThis.Number(object.cacheTook) : 0,
      cacheHit: isSet(object.cacheHit) ? globalThis.Boolean(object.cacheHit) : false,
    };
  },

  toJSON(message: ProtoSearchResult): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => ProtoBookSearchItem.toJSON(e));
    }
    if (message.tags?.length) {
      obj.tags = message.tags.map((e) => ProtoDefinedTag.toJSON(e));
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    if (message.took !== 0) {
      obj.took = Math.round(message.took);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.cacheKey !== "") {
      obj.cacheKey = message.cacheKey;
    }
    if (message.cacheTook !== 0) {
      obj.cacheTook = Math.round(message.cacheTook);
    }
    if (message.cacheHit !== false) {
      obj.cacheHit = message.cacheHit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoSearchResult>, I>>(base?: I): ProtoSearchResult {
    return ProtoSearchResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoSearchResult>, I>>(object: I): ProtoSearchResult {
    const message = createBaseProtoSearchResult();
    message.items = object.items?.map((e) => ProtoBookSearchItem.fromPartial(e)) || [];
    message.tags = object.tags?.map((e) => ProtoDefinedTag.fromPartial(e)) || [];
    message.totalPages = object.totalPages ?? 0;
    message.took = object.took ?? 0;
    message.page = object.page ?? 0;
    message.cacheKey = object.cacheKey ?? "";
    message.cacheTook = object.cacheTook ?? 0;
    message.cacheHit = object.cacheHit ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
